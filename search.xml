<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>批处理模式运行EDEM</title>
      <link href="/c5634a1b.html"/>
      <url>/c5634a1b.html</url>
      
        <content type="html"><![CDATA[<h2 id="批处理模式运行edem">批处理模式运行EDEM</h2><h1 id="edem的命令行界面cli">EDEM的命令行界面（CLI）</h1><p>通过EDEM的命令行界面，你可以在批处理模式下运行EDEM而不使用GUI。你可能想在以下情况下这样做。</p><ul><li>你有一个显示能力有限的集群，想做网格处理。</li><li>你需要创建批处理作业来运行EDEM的模拟。</li><li>你想为参数优化开发高级脚本。</li><li>一旦模拟完成，EDEM也可以将数据导出到.csv文件。</li></ul><h2 id="使用命令行">使用命令行</h2><p>EDEM命令行对Windows和Linux都有相同的标志。 <code>edem.exe --console -i "input.dem" [处理标志][后处理标志]</code> 当从命令行使用EDEM时，可以用以下方式显示帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edem.exe -h</span><br></pre></td></tr></table></figure><h3 id="必要的标志required-flags">必要的标志(Required Flags)</h3><table><thead><tr class="header"><th>Switch</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>-f/-i <string></td><td>Input deck.</td></tr></tbody></table><h3 id="处理标志processing-flags">处理标志(Processing Flags)</h3><p>处理标志设置模拟器的选项，如模拟时间、时间步长和处理器数量。你也可以在命令行中指定要使用的许可证服务器。如果你没有指定任何处理标志，将使用存储在模拟平台中的值。如果模拟平台中没有保存的值，那么将使用默认值。</p><table><thead><tr class="header"><th style="text-align: center;">Switch</th><th style="text-align: center;">Description</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">c/--console/--script</td><td style="text-align: center;">仅在控制台的模式下运行EDEM。</td></tr><tr class="even"><td style="text-align: center;">-r/--run-time <double></td><td style="text-align: center;">总运行时间，默认值=1。</td></tr><tr class="odd"><td style="text-align: center;">-w/--write-out <double></td><td style="text-align: center;">保存时间间隔，默认值=1e-05。</td></tr><tr class="even"><td style="text-align: center;">-g/--cell-size <double></td><td style="text-align: center;">网格单元大小（R min），默认值=2。</td></tr><tr class="odd"><td style="text-align: center;">-t/--time-step <double></td><td style="text-align: center;">时间步长，默认值为1.0e-06。设为0以启用自动时间步长。</td></tr><tr class="even"><td style="text-align: center;">-p/--processors <int></td><td style="text-align: center;">处理器的数量，默认值=1。</td></tr><tr class="odd"><td style="text-align: center;">-R/--rewind</td><td style="text-align: center;">倒退模拟到开始。</td></tr><tr class="even"><td style="text-align: center;">--particle-properties</td><td style="text-align: center;">重新计算所有材料的粒子属性。</td></tr><tr class="odd"><td style="text-align: center;">-E/--engine [0|1]</td><td style="text-align: center;">0=CPU求解器，1=GPU求解器。默认值为0。</td></tr><tr class="even"><td style="text-align: center;">-D --device [0|1|...]</td><td style="text-align: center;">设备索引。+可用于多设备，如0+1。</td></tr><tr class="odd"><td style="text-align: center;">--particle-properties</td><td style="text-align: center;">重新计算所有材料的粒子属性（质量/惯性）。如果粒子属性已经被外部程序修改，则适用。</td></tr><tr class="even"><td style="text-align: center;">-n/--steps-total <int></td><td style="text-align: center;">运行模拟的给定步数。</td></tr><tr class="odd"><td style="text-align: center;">--wait-processor-key</td><td style="text-align: center;">如果没有可用的处理器密钥，EDEM将等待，并在CPU许可空闲时启动模拟。(仅适用于传统的)</td></tr><tr class="even"><td style="text-align: center;">--dyn [0|1]</td><td style="text-align: center;">启用动态域。</td></tr><tr class="odd"><td style="text-align: center;">--dyn-interval <double></td><td style="text-align: center;">设置动态域的检查间隔，默认值为0.1秒。</td></tr><tr class="even"><td style="text-align: center;">--dyn-check <int></td><td style="text-align: center;">设置动态域的检查次数，默认值为3。</td></tr><tr class="odd"><td style="text-align: center;">--dyn-disp <double></td><td style="text-align: center;">设置动态域的粒子位移，默认值为R min的10%。</td></tr><tr class="even"><td style="text-align: center;">--gpu-split <string></td><td style="text-align: center;">设置gpu分割轴，默认值为X。</td></tr><tr class="odd"><td style="text-align: center;">--wait-license-key</td><td style="text-align: center;">等待许可证密钥（CPU、GPU、API和耦合器），直到它们可用。(只限于传统的)</td></tr><tr class="even"><td style="text-align: center;">--simExport</td><td style="text-align: center;">每一个写出的间隔时间导出数据。必须与配置文件中的文本导出名称相匹配。</td></tr><tr class="odd"><td style="text-align: center;">--compress-data</td><td style="text-align: center;">在打开/关闭压缩数据的情况下运行仿真0=禁用或1=启用数据压缩。默认为机器压缩设置，除非已经在仿真中设置。</td></tr><tr class="even"><td style="text-align: center;">--acd</td><td style="text-align: center;">在运行仿真时开启/关闭替代性接触检测方法0=禁用或1=启用GPU上的替代性接触检测。默认为关闭，除非已经在仿真中设置</td></tr><tr class="odd"><td style="text-align: center;">--sp</td><td style="text-align: center;">以单精度运行替代接触检测方法0=禁用或1=启用单精度。</td></tr></tbody></table><h3 id="从命令行运行动态域">从命令行运行动态域</h3><p>要从命令行运行EDEM动态域，需要在标志<code>--dyn</code> 后面加上数字0或1。</p><ul><li><code>--dyn 0</code> 禁用动态域</li><li><code>--dyn 1</code> 启用动态域</li></ul><p>这将以下列默认值运行动态域。</p><ul><li>检查间隔:0.1</li><li>检查次数:3</li><li>粒子位移:10%</li></ul><p>可以用处理标志表中定义的标志来指定 "检查间隔"、"检查次数 "和 "粒子位移值"。 那么，一个带有动态域的命令行的例子是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edem.exe --console -i simulation_deck.dem -p 4 -r 2 -w 0.1 -g 4 -t 1-6 --dyn 1 --dyn-interval 0.15 --dyn-check 4 --dyn-disp 15</span><br></pre></td></tr></table></figure><p>这将使用一个动态域，具有。</p><ul><li>检查间隔：0.15s</li><li>检查次数:4</li><li>粒子的位移:15%的Rmin</li></ul><h3 id="后处理标志">后处理标志</h3><p>使用后处理标志来指定数据导出参数。您可以指定要导出的数据类型（全部、粒子、几何体等），也可以指定仿真的配置文件。 如果您想从命令行导出数据，首先从分析器中选择文件&gt;导出&gt;结果数据，设置导出的路径和文件名以及所需的查询。</p><table><colgroup><col style="width: 24%" /><col style="width: 76%" /></colgroup><thead><tr class="header"><th>Switch</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>-e/--export [A|P|G|C|K] <string></td><td>输出的数据类型和文件名(.csv) A - 输出所有数据 P - 输出粒子数据 G - 输出几何数据 C - 输出接触数据 K - 输出碰撞数据</td></tr><tr class="even"><td>-e <string></td><td>指定输出数据的<code>.dfg</code>文件的文件名。</td></tr></tbody></table><p>在任何EDEM模拟中，导出数据设置都是在EDEM Analyst中设置的。如果用户有一系列需要相同数据导出选项的模拟，只需要在一个模拟中设置所需的查询。这些查询被保存在<code>simulation_name.dfg</code>文件中。这可以被复制和重命名，当使用<code>-e</code>标志时，<code>.dfg</code>文件不必与<code>.dem</code>标志的名称相同，例如。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edem.exe --console -i &quot;input1.dem&quot; -e &quot;export_queries.dfg&quot;</span><br><span class="line">edem.exe --console -i &quot;input2.dem&quot; -e &quot;export_queries.dfg&quot;</span><br><span class="line">edem.exe --console -i &quot;input3.dem&quot; -e &quot;export_queries.dfg&quot;</span><br></pre></td></tr></table></figure><p>这将从3次模拟中导出相同的先前定义的数据，由于这些数据将以相同的文件名导出（例如results.csv），建议在每次模拟后重新命名结果文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">edem.exe -–console –i “input1.dem” -e “export_queries.dfg”</span><br><span class="line">rename results.csv results1.csv</span><br><span class="line">edem.exe -–console –i “input2.dem” -e “export_queries.dfg”</span><br><span class="line">rename results.csv results2.csv</span><br><span class="line">edem.exe -–console –i “input3.dem” -e “export_queries.dfg”</span><br><span class="line">rename results.csv results3.csv</span><br></pre></td></tr></table></figure><h3 id="其他标志">其他标志</h3><p>EDEM包含额外的标志，在某些情况下可能很有用</p><table><thead><tr class="header"><th>Switch</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>-?/-h/--help</td><td>显示帮助。</td></tr><tr class="even"><td>-v/--version</td><td>显示版本。</td></tr><tr class="odd"><td>--no-free</td><td><Windows>在GUI模式下不要从控制台释放EDEM。</td></tr><tr class="even"><td>--file-logger <string></td><td>打印所有输出日志到文件。</td></tr><tr class="odd"><td>--server-dialog</td><td>显示服务器选择对话框。</td></tr><tr class="even"><td>-S/--server <string></td><td>将许可证服务器设置为指定的字符串。(Altair Licensing这是特定的实例-它不会更新默认的许可证服务器)</td></tr><tr class="odd"><td>--cs</td><td>启用EDEM耦合服务器。</td></tr><tr class="even"><td>--auto-grid</td><td>启用自动网格大小调整。</td></tr><tr class="odd"><td>--wait</td><td>防止耦合仿真后的连接清理。</td></tr><tr class="even"><td>-L/--legacy-display</td><td>使用传统的图形。</td></tr><tr class="odd"><td>-s/--sim</td><td>在 "仅仿真器 "模式下打开EDEM。</td></tr><tr class="even"><td>-convert <string></td><td>转换Deck的目的地。</td></tr><tr class="odd"><td>--rg</td><td>替换几何图形见下面的章节。</td></tr></tbody></table><h3 id="替换几何体">替换几何体</h3><p>替换几何体的命令需要一个配置文件。 这个文件包含了每个被替换的几何体的相关信息。 这个文件的格式在下面的例子中有所概述。 对于每个要替换的部分，包括一个格式如下的行，其中分隔线是 "hash "字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;cfg file section&gt; # &lt;target section name&gt; # &lt;CAD file&gt; # &lt;import units&gt; # &lt;Geometry material&gt; # &lt;mesh (y&#x2F;n)&gt; # &lt;Min Size&#x2F;Element Size&gt; # &lt;Max Size&gt; # &lt;Max Deviation&gt; # &lt;Max Angle&gt;</span><br><span class="line">&lt;cfg文件部分&gt; # &lt;目标部分名称&gt; # &lt;CAD文件&gt; # &lt;输入单位&gt; # &lt;几何材料&gt; # &lt;网格（y&#x2F;n）&gt; # &lt;最小尺寸&#x2F;元素尺寸&gt; # &lt;最大尺寸&gt; # &lt;最大偏差&gt; # &lt;最大角度&gt;</span><br></pre></td></tr></table></figure><p>如果使用网格划分选项 "n"，将使用默认的网格导入选项。如果使用 "y"，"y "后面的参数数量将决定使用的方法。 单一数值将使用尺寸和偏置方法，四个数值将使用刚体方法。更多细节见下面的例子。</p><blockquote><p>注意：cfg文件部分是每个对象的唯一标识符--这可以分配任何数值，只要它对文件中使用的任何其他cfg文件部分是唯一的。</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Section1 # guide 1 # D:\Wall21.stl # m # steel # n </span><br><span class="line">几何图形将使用默认的网格选项导入</span><br><span class="line">Section2 # guide 2 # D:\Wall22.stl # mm # steel # y # 10</span><br><span class="line">几何图形将使用尺寸和偏置方法导入，元素尺寸为10mm</span><br><span class="line">Section3 # guide 3 # D:\Wall23.stl # mm # steel # y # 10 # 100 # 1 # 15 </span><br><span class="line">几何体将使用刚体方法和所示的四个参数导入</span><br></pre></td></tr></table></figure><p>然后从命令行中引用该配置文件，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--console -i td.dem --rg rgconfig.txt -R</span><br></pre></td></tr></table></figure> 停止命令行模拟 命令行模拟会一直运行到模拟结束时间，可以在模拟器中设置或通过-t标志设置。<br />此外，用户可以通过在simulation_name.dem文件的同一文件夹中创建<simulation_name>.dem.stop文件来停止命令行仿真。</p><h3 id="命令行处理输出">命令行处理输出</h3><p>在处理过程中，EDEM命令行以固定的时间间隔输出一排数字。从左到右，这几列对应表示。</p><ul><li>时间步骤的数量。</li><li>仿真时间（秒）。</li><li>处理时间（s）。</li><li>处理一秒模拟时间的预期时间（s）。</li><li>总的线性动能（J）。</li><li>总的旋转动能（J）。</li></ul><h3 id="案例">案例</h3><h4 id="例1默认处理选项">例1：默认处理选项</h4><ol type="1"><li>使用EDEM创建器创建并保存一个Deck文件。</li><li>打开一个控制台（cmd）窗口，然后输入以下内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edem.exe --console -i &quot;c:\My Documents\EDEM\mysim.dem&quot; --rewind</span><br></pre></td></tr></table></figure><p>仿真被倒回起点，然后处理每个时间步骤。一旦完成，将显示一条信息。然后你可以打开Deck，用EDEM分析器进行任何后处理。</p><h4 id="例2指定处理选项">例2：指定处理选项</h4><ol type="1"><li>使用EDEM Creator创建并保存一个Deck文件。</li><li>打开一个控制台（cmd）窗口，然后改变目录到EDEM bin目录。</li><li>输入以下内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edem.exe --console -i &quot;c:\My Documents\EDEM\mysim.dem&quot; –p 4 –r 10</span><br></pre></td></tr></table></figure><p>该命令使用4个处理器运行模拟，总运行时间为10秒。</p><h4 id="例3运行模拟并输出数据">例3：运行模拟并输出数据</h4><ol type="1"><li>使用EDEM Creator创建并保存一个Deck文件。</li><li>打开一个控制台（cmd）窗口，然后改变目录到EDEM bin目录。</li><li>输入以下内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edem.exe --console -i &quot;c:\My Documents\EDEM\mysim.dem&quot; --rewind -ePC &quot;c:\My Documents\EDEM\mysimdata.csv&quot;</span><br></pre></td></tr></table></figure><p>这个命令回退时间，然后使用默认的处理标志运行模拟。然后它将粒子和接触数据导出到一个.csv文件。 #### 例4：根据甲板配置运行模拟并导出数据</p><ol type="1"><li>使用EDEM Creator创建并保存一个Deck文件。</li><li>切换到分析器，然后选择文件&gt;导出&gt;结果数据。</li><li>定义导出查询，然后设置文件名。点击关闭。</li><li>切换回Creator，然后保存你的Deck。配置文件将被更新，并包含导出查询的详细信息。</li><li>打开一个控制台（cmd）窗口，然后改变目录到EDEM bin目录。</li><li>输入以下内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edem.exe --console -i &quot;c:\My Documents\EDEM\mysim.dem&quot; --rewind -e &quot;c:\My Documents\EDEM\mysim.dfg&quot;</span><br></pre></td></tr></table></figure><p>这个命令回退时间，然后使用默认的处理标志运行模拟。然后它根据deck配置文件中定义的查询导出数据。</p>]]></content>
      
      
      <categories>
          
          <category> EDEM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edempy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python通用编程</title>
      <link href="/5d42378d.html"/>
      <url>/5d42378d.html</url>
      
        <content type="html"><![CDATA[<h1 id="名称空间">名称空间</h1><h2 id="名称空间-1">名称空间</h2><p>我们可以使用类名加<code>.dict</code>方法，查看类的名称空间，那么对象的名称空间能不能查看呢？</p><p>在定义类的阶段产生类的名称空间，那么什么时候产生对象的名称空间呢？你要先告诉我什么时候产生对<br />象，只有在调用类的时候才会产生对象，这个时候就会产生出对象的名称空间，有了名称空间就是把对象存好了，但是存不是目的，我们目的是取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name  <span class="comment"># 把name这个属性放进对象的名称空间中</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Deep的名称空间&quot;</span>, DeepshareStudent.__dict__)</span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Deep的名称空间&quot;</span>, DeepshareStudent.__dict__)</span><br><span class="line">print(stu1.__dict__)</span><br><span class="line">print(stu1.__dict__[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">print(stu1.name)</span><br></pre></td></tr></table></figure><pre><code>Deep的名称空间 &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;school&#39;: &#39;deepshare&#39;, &#39;__init__&#39;: &lt;function DeepshareStudent.__init__ at 0x000001CB92353288&gt;, &#39;learn&#39;: &lt;function DeepshareStudent.learn at 0x000001CB92353AF8&gt;, &#39;eat&#39;: &lt;function DeepshareStudent.eat at 0x000001CB92353438&gt;, &#39;sleep&#39;: &lt;function DeepshareStudent.sleep at 0x000001CB92353678&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;DeepshareStudent&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;DeepshareStudent&#39; objects&gt;, &#39;__doc__&#39;: None&#125;Deep的名称空间 &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;school&#39;: &#39;deepshare&#39;, &#39;__init__&#39;: &lt;function DeepshareStudent.__init__ at 0x000001CB92353288&gt;, &#39;learn&#39;: &lt;function DeepshareStudent.learn at 0x000001CB92353AF8&gt;, &#39;eat&#39;: &lt;function DeepshareStudent.eat at 0x000001CB92353438&gt;, &#39;sleep&#39;: &lt;function DeepshareStudent.sleep at 0x000001CB92353678&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;DeepshareStudent&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;DeepshareStudent&#39; objects&gt;, &#39;__doc__&#39;: None&#125;&#123;&#39;name&#39;: &#39;王二小&#39;, &#39;age&#39;: 18, &#39;gender&#39;: &#39;male&#39;&#125;王二小王二小</code></pre><p>现在我们定义的类做一下修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line">    name = <span class="string">&quot;aaaaaaaaaa&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(stu1.name)  <span class="comment"># init函数中有name</span></span><br><span class="line">print(stu1.school)</span><br></pre></td></tr></table></figure><pre><code>王二小deepshare</code></pre><p>很明显我用对象找他的独有的name属性 就应该从init中找name</p><p>但是，如果init函数中没有呢？</p><p>这个对象stu1会先从他自己对象的名称空间中找school这个属性，但是他发现没有这个属性，那就后退一级，往类的名称空间中找，注意对象的名称空间和类的名称空间不是一个概念，接下来我们会说明这个问题</p><p>如果类的名称空间中没有，他还会往上找吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    name = <span class="string">&quot;aaaaaaaaaa&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">print(stu1.school)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-6-5b94cae47be0&gt; in &lt;module&gt;     21      22 stu1 = DeepshareStudent(&quot;王二小&quot;, 18, &quot;male&quot;)---&gt; 23 print(stu1.school)AttributeError: &#39;DeepshareStudent&#39; object has no attribute &#39;school&#39;</code></pre><p>肯定是不能的，写代码的时候Pycharm就会有错误的提示了，现在school是定义在全局，与对象stu1没有任何关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">print(DeepshareStudent.__dict__)</span><br><span class="line">print(<span class="built_in">id</span>(DeepshareStudent.__dict__))</span><br><span class="line">print(stu1.__dict__)</span><br><span class="line">print(<span class="built_in">id</span>(stu1.__dict__))</span><br><span class="line">print(<span class="built_in">id</span>(stu2.__dict__))</span><br></pre></td></tr></table></figure><pre><code>&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;school&#39;: &#39;deepshare&#39;, &#39;__init__&#39;: &lt;function DeepshareStudent.__init__ at 0x00000127D29D48B8&gt;, &#39;learn&#39;: &lt;function DeepshareStudent.learn at 0x00000127D29D4948&gt;, &#39;eat&#39;: &lt;function DeepshareStudent.eat at 0x00000127D29D49D8&gt;, &#39;sleep&#39;: &lt;function DeepshareStudent.sleep at 0x00000127D29D4A68&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;DeepshareStudent&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;DeepshareStudent&#39; objects&gt;, &#39;__doc__&#39;: None&#125;1270548332504&#123;&#39;name&#39;: &#39;王二小&#39;, &#39;age&#39;: 18, &#39;gender&#39;: &#39;male&#39;&#125;12705489226801270548819464</code></pre><p>我现在造了两个对象stu1和stu2，打印结果可以说明，他们分别有自己的内存空间，类也有自己的内存空间，那么这之间有什么关系呢？</p><p><img src= "img/ballloading.gif" data-lazy-src="attachment:f58bad1b-6343-4cac-8083-decca3ab2d62.png" alt="image.png" /> &gt;他们三部分是完全独立的，没有包含与被包含的关系，只不过用对象点属性做属性查找的时候先从对象的名称空间中查找，如果能够找到，就是使用对象的名称空间存的，如果找不到就取类的名称空间中找，再找不到就要报错了，错误提示：对象没有这个属性。</p><h2 id="绑定方法">绑定方法</h2><p>前面我们研究是对象的特征（用变量表示的，接下来我们来研究对象的技能（用函数来表示的），不管是特征还是技能这些都是对象的属性，这是我们前面已经证明过的，那么接下来我们就来调用对象的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span>  <span class="comment"># 该变量属性所有对象共用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span>  <span class="comment"># 类实例化的不同对象，有各自的名称空间。self为其对象本身</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">print(DeepshareStudent.learn)</span><br><span class="line">print(stu1.learn)</span><br><span class="line">print(stu2.learn)</span><br><span class="line">print(<span class="built_in">id</span>(DeepshareStudent.school))</span><br><span class="line">print(<span class="built_in">id</span>(stu1.school))</span><br><span class="line">print(<span class="built_in">id</span>(stu2.school))</span><br></pre></td></tr></table></figure><pre><code>&lt;function DeepshareStudent.learn at 0x00000127D2952558&gt;&lt;bound method DeepshareStudent.learn of &lt;__main__.DeepshareStudent object at 0x00000127D290B348&gt;&gt;&lt;bound method DeepshareStudent.learn of &lt;__main__.DeepshareStudent object at 0x00000127D290B108&gt;&gt;127054826673612705482667361270548266736</code></pre><p>从输出结果我们可以看到用类来调learn属性拿到的是一个普通方法，而用对象去调learn属性拿到的是</p><blockquote><p>绑定方法，这个方法是绑定到类属性上的</p></blockquote><blockquote><p>我们再来理解一下，类是直接从自己的名称空间中拿到learn属性，而对象在自己的名称空间中找learn属性没有找到，就要到类的名称空间中去找，相当于是间接拿到了learn属性。类内部定义的函数自己能使用，但主要是给对象用的。再来看一下内存地址，上面三个函数属性的内存地址是完全不同的，而下面三个变量属性的内存地址是完全一样的。这是因为类内部的变量是直接给对象使用，而类内部的函数是绑定给对象使用，这怎么理解呢</p></blockquote><p>你们大家都是Deepshare的学生，都有一个相似的技能叫做学习，但是你学习能学到小明身上了，你学习并不能代表小明学习，虽然你们都具有学习的功能。这就叫绑定方法，大家用的是同一个功能，但是绑定给谁，就是谁在执行</p><p>那么这在程序中怎么体现呢？（其实我们前面的代码已经用过了，只是我还没讲）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is learning&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">DeepshareStudent.learn(<span class="string">&quot;albert&quot;</span>)</span><br><span class="line">stu1.learn()</span><br></pre></td></tr></table></figure><pre><code>is learningis learning</code></pre><blockquote><p>执行代码，我们会发现，类调用learn方法必须要传一个参数，而stu1调用learn方法不需要传参数，但是learn确实是需要一个参数的，那就说明他是自动传了一个参数，我们怎么验证呢</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is learning&quot;</span>, self)  <span class="comment"># 打印一下self就知道了</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">DeepshareStudent.learn(<span class="string">&quot;albert&quot;</span>)</span><br><span class="line">stu1.learn()</span><br><span class="line">print(stu1)</span><br></pre></td></tr></table></figure><pre><code>is learning albertis learning &lt;__main__.DeepshareStudent object at 0x00000127D294BF88&gt;&lt;__main__.DeepshareStudent object at 0x00000127D294BF88&gt;</code></pre><p>仔细看看是不是一样的</p><p>这就说明stu1调用learn方法本质原理就是把它自己传进来</p><p>这就是绑定方法，类内部定义的函数，类可以使用，但是类来使用的时候就是一个普通函数，普通函数有几个参数就传几个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(DeepshareStudent.learn)</span><br><span class="line">DeepshareStudent.learn(<span class="string">&quot;albert&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;function DeepshareStudent.learn at 0x00000127D29D4DC8&gt;is learning albert</code></pre><p>但是类内部定义的函数其实是为了给对象用的，而且是绑定给对象用的，绑定给不同的对象，就是不同的绑定方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(stu1.learn)</span><br><span class="line">print(stu2.learn)</span><br></pre></td></tr></table></figure><pre><code>&lt;bound method DeepshareStudent.learn of &lt;__main__.DeepshareStudent object at 0x00000127D294BF88&gt;&gt;&lt;bound method DeepshareStudent.learn of &lt;__main__.DeepshareStudent object at 0x00000127D294BCC8&gt;&gt;</code></pre><p>绑定方法的特殊之处在于谁来调用，就会把谁当作第一个参数自动传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is learning&quot;</span>, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu1.learn()</span><br><span class="line">stu2.learn()</span><br></pre></td></tr></table></figure><pre><code>is learning &lt;__main__.DeepshareStudent object at 0x00000127D293FA88&gt;is learning &lt;__main__.DeepshareStudent object at 0x00000127D293F308&gt;</code></pre><p>接下来我们单独用stu1来说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="comment"># self=stu1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self.name)  <span class="comment"># self就是stu1，stu1有name方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu1.learn()</span><br><span class="line">stu2.learn()</span><br></pre></td></tr></table></figure><pre><code>王二小 is learning王三小 is learning</code></pre><blockquote><p>综上所述</p></blockquote><p><strong><code>类内部的变量是给所有对象共享，所有对象指向的都是同一个内存地址</code>； 类内部定义的函数其实是为了给对象用的，而且是绑定给对象用的，绑定给不同的对象，就是不同的绑定方法</strong></p><p><strong>类内部定义的函数必须要有self这个参数，但也可以有别的参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self, course</span>):</span>  <span class="comment"># 在添加一个函数</span></span><br><span class="line">        print(<span class="string">&quot;%s is choosing %s&quot;</span> % (self.name, course))  <span class="comment"># 传一个course参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu1.choose(<span class="string">&quot;Python&quot;</span>)  <span class="comment"># 传一个实参</span></span><br><span class="line">stu2.choose(<span class="string">&quot;AI&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>王二小 is choosing Python王三小 is choosing AI</code></pre><p>我们在使用Pycharm工具的时候，遇到括号里面需要传参，Pycharm会自动给我们提示参数的形参，当我们遇到self这个参数的，就当成没有这参数，只需要传其他的参数就可以了，现在你理解了，因为self是会自动传参值的，而且是自动把它本身当作第一个参数传入。</p><h2 id="一切皆对象">一切皆对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self, course</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is choosing %s&quot;</span> % (self.name, course))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">print(stu1)</span><br><span class="line">print(<span class="built_in">type</span>(stu1))</span><br><span class="line">print(<span class="built_in">id</span>(stu1))</span><br></pre></td></tr></table></figure><pre><code>&lt;__main__.DeepshareStudent object at 0x00000127D29DFB08&gt;&lt;class &#39;__main__.DeepshareStudent&#39;&gt;1270548921096</code></pre><p>一个等号表示赋值，stu1其实就是我们定义的一个变量，第一天我们就说过了，一个变量有id，type和值，他的值没什么好说的，就是一个Deepshare类的对象，id就是表示它的内存地址，这也没什么好说的，我们来看stu1的类型是什么 ，忽略main，stu1的类型就是Deepshare，stu1的类也是Deepshare，所以在 Python中</p><blockquote><p>类与类型是一个概念</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is learning&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self, course</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is choosing %s&quot;</span> % (self.name, course))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is eating&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is sleeping&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;王二小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu2 = DeepshareStudent(<span class="string">&quot;王三小&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">print(<span class="built_in">int</span>)</span><br><span class="line">print(<span class="built_in">str</span>)</span><br><span class="line">print(<span class="built_in">list</span>)</span><br><span class="line">print(<span class="built_in">tuple</span>)</span><br><span class="line">print(<span class="built_in">set</span>)</span><br><span class="line">print(<span class="built_in">dict</span>)</span><br><span class="line">print(DeepshareStudent)</span><br></pre></td></tr></table></figure><pre><code>&lt;class &#39;int&#39;&gt;&lt;class &#39;str&#39;&gt;&lt;class &#39;list&#39;&gt;&lt;class &#39;tuple&#39;&gt;&lt;class &#39;set&#39;&gt;&lt;class &#39;dict&#39;&gt;&lt;class &#39;__main__.DeepshareStudent&#39;&gt;</code></pre><h2 id="对象属性的增删改查">对象属性的增删改查</h2><h3 id="查看">查看</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    n = <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Bar(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">print(obj.__dict__)</span><br><span class="line">print(obj.x)</span><br><span class="line">print(obj.n)</span><br></pre></td></tr></table></figure><pre><code>&#123;&#39;x&#39;: &#39;abc&#39;&#125;abc1111</code></pre><h3 id="添加">添加</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    n = <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Bar(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">print(obj.__dict__)</span><br><span class="line">print(obj.x)</span><br><span class="line">print(obj.n)</span><br><span class="line">obj.abc = <span class="string">&quot;abc&quot;</span></span><br><span class="line">print(obj.abc)</span><br></pre></td></tr></table></figure><pre><code>&#123;&#39;x&#39;: &#39;abc&#39;&#125;abc1111abc</code></pre><h3 id="删除">删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    n = <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Bar(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">print(obj.__dict__)</span><br><span class="line">print(obj.x)</span><br><span class="line">print(obj.n)</span><br><span class="line">obj.abc = <span class="string">&quot;abc&quot;</span></span><br><span class="line">print(obj.abc)</span><br><span class="line">obj.abc = <span class="string">&quot;123&quot;</span></span><br><span class="line">print(obj.abc)</span><br><span class="line"><span class="keyword">del</span> obj.abc</span><br><span class="line"><span class="comment"># print(obj.abc)</span></span><br></pre></td></tr></table></figure><pre><code>&#123;&#39;x&#39;: &#39;abc&#39;&#125;abc1111abc123</code></pre><h3 id="修改">修改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    n = <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Bar(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">print(obj.__dict__)</span><br><span class="line">print(obj.x)</span><br><span class="line">print(obj.n)</span><br><span class="line">obj.abc = <span class="string">&quot;abc&quot;</span></span><br><span class="line">print(obj.abc)</span><br><span class="line">obj.abc = <span class="string">&quot;123&quot;</span></span><br><span class="line">print(obj.abc)</span><br></pre></td></tr></table></figure><pre><code>&#123;&#39;x&#39;: &#39;abc&#39;&#125;abc1111abc123</code></pre><h2 id="随堂练习">随堂练习</h2><h3 id="练习一">练习一</h3><p>实现这样一个功能，有一个对象，他有一个count属性，count属性是统计他所在的类产生了多少个对象，即print(obj.count)能打印出对象的个数</p><p>分析：</p><p>既然要统计有多少个对象，那么只要有一个对象就要执行一次类的调用，调用一次类，其实就要执行类内部的init函数，所以我们在init函数里面写上相应的逻辑就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 = Foo()</span><br><span class="line">obj2 = Foo()</span><br><span class="line">obj3 = Foo()</span><br><span class="line">print(obj1.count)</span><br></pre></td></tr></table></figure><pre><code>1</code></pre><p>这是什么原因呢？ &gt; self是对象自己，obj1，obj2和obj3是互不相通的，虽然每次count都会加一，但是其实每个对象 都有自己的独一份的count，初始值永远是0，每次来都是加1，所以永远是1</p><p>我们应该对他们共享的那个属性来做修改，什么属性是共享的呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        Foo.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 = Foo()</span><br><span class="line">obj2 = Foo()</span><br><span class="line">obj3 = Foo()</span><br><span class="line">print(obj1.count)</span><br></pre></td></tr></table></figure><pre><code>3</code></pre><p>虽然这次我们没有在对象自己的名称空间中添加count属性，但是类里面有啊，对象在做属性查找的时候先从自己的名称空间中找，没有就去他所在的类里面找，在类里面，这个count变量属性是所有对像共用的。</p><h3 id="练习二">练习二</h3><p>实现一个人狗大战的程序，人可以咬狗，狗也可以咬人，人和狗都有自己的生命值，被咬了之后会掉血，当生命值为0时，人或者狗就死了</p><p>按照步骤我们先总结出现实中的对象</p><p>现实中的人类 """ 人1 特征： 名字='张二炮' 攻击力=60 生命值=100 技能： 咬 人2 特征： 名字='刘老三' 攻击力=50 生命值=100 技能： 咬 现实中的人类 相同的特征 无 相同的技能 咬 """ 现实中的狗类 """ 狗1 特征： 名字='旺财' 品种="京巴" 攻击力=80 生命值=50 技能： 咬 狗2 特征： 名字='小黑' 品种="藏獒" 攻击力=200 生命值=200 技能： 咬 现实中的狗类 相同的特征 无 相同的技能 咬 """</p><p>注意：</p><p>两个人虽然有相同的特征的，都有名字，攻击力，和生命值，但是这是他们每个人独立的，例如章二炮被咬了之后，他的生命值下降，而刘老三没有被咬，还是原来的值，所以我们定义现实中的人类是没有相同的特征的，同理，现实中的狗类也是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, aggressivity, life_value=<span class="number">100</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.aggressivity = aggressivity</span><br><span class="line">        self.life_value = life_value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意：咬肯定不能咬自己，一定是咬敌人，所以要传一个敌人参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bite</span>(<span class="params">self, enemy</span>):</span>  <span class="comment"># self=p1   enemy=d1</span></span><br><span class="line">        enemy.life_value -= self.aggressivity</span><br><span class="line">        <span class="keyword">if</span> enemy.life_value &gt;= <span class="number">0</span>:</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            人[%s] 咬了一口狗 [%s]</span></span><br><span class="line"><span class="string">            狗掉血[%s]</span></span><br><span class="line"><span class="string">            狗还剩血量[%s]</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">                % (self.name, enemy.name, self.aggressivity, enemy.life_value)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;%s死了&quot;</span> % enemy.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, dog_type, aggressivity, life_value</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.dog_type = dog_type</span><br><span class="line">        self.aggressivity = aggressivity</span><br><span class="line">        self.life_value = life_value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bite</span>(<span class="params">self, enemy</span>):</span>  <span class="comment"># self = d1    enemy= p1</span></span><br><span class="line">        enemy.life_value -= self.aggressivity</span><br><span class="line">        <span class="keyword">if</span> enemy.life_value &gt;= <span class="number">0</span>:</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            狗[%s] 咬了一口人 [%s]</span></span><br><span class="line"><span class="string">            人掉血[%s]</span></span><br><span class="line"><span class="string">            人还剩血量[%s]</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">                % (self.name, enemy.name, self.aggressivity, enemy.life_value)</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125;死了&quot;</span>.<span class="built_in">format</span>(enemy.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = People(<span class="string">&quot;张二炮&quot;</span>, <span class="number">60</span>)</span><br><span class="line">d1 = Dog(<span class="string">&quot;小黑&quot;</span>, <span class="string">&quot;藏獒&quot;</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">p1.bite(d1)</span><br><span class="line">d1.bite(p1)</span><br></pre></td></tr></table></figure><pre><code>            人[张二炮] 咬了一口狗 [小黑]            狗掉血[60]            狗还剩血量[140]            张二炮死了</code></pre><h1 id="三大特性">三大特性</h1><h2 id="继承">继承</h2><p>我们一直在说面向对象扩展性高，从来不知道他的扩展性高体现在哪些方面，接下来我们就来介绍他的三大特性，三大特性分别是继承，多肽和封装，他的特性也是我们以后使用面向对象的一些技巧，第一个我们来说的就是继承。</p><h3 id="继承的基本介绍">继承的基本介绍</h3><p>什么是继承</p><p>继承是一种新建类的方式，我以前定义的类都是class关键字加类名，在Python中支持多继承，就是一个儿子可以继承多个爹，这一点和其他的某些语言不同</p><p>从字面意思上理解就是你继承你爹的东西，他继承他爹的东西，继承就像一种遗传的关系，你爹有钱，你也有钱，要是你没钱，那可能你是你爹充话费送的，你爹有一套房子，你也可以跑进去住一下，当然如果你自己有房子，肯定会优先住你自己房子</p><p>继承新建的类称为子类或者派生类，被继承的类称为，父类，基类或者超类，子类会遗传父类的属性</p><p>假如你爹给你留了一个亿，你还有必要像其他同学一样苦逼呵呵的在这学Python吗，你就可以直接拿着这个钱来花，不用在自己挣钱，不用自己造了，可事实上你爹一毛都没留给你，所以你要靠自己。</p><p>为什么要用继承</p><p>所以使用继承就是为了减少代码冗余</p><p>怎么用继承</p><p>继承应该有爹有儿子，下面我们来写代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass1</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass2</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单继承，原来类名后面直接加冒号，现在我们可以先加括号，括号里面写他的父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass1</span>(<span class="params">ParentClass1</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python中支持多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span>(<span class="params">ParentClass1, ParentClass2</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># base是基础的意思，这个方法是查看他的父类</span></span><br><span class="line">print(SubClass1.__bases__)</span><br><span class="line">print(SubClass2.__bases__)</span><br></pre></td></tr></table></figure><pre><code>(&lt;class &#39;__main__.ParentClass1&#39;&gt;,)(&lt;class &#39;__main__.ParentClass1&#39;&gt;, &lt;class &#39;__main__.ParentClass2&#39;&gt;)</code></pre><p>他的父类会以元祖的形式现实出来</p><p>到目前位置我们大概知道了继承是怎么一回事，接下来我们先补充一个简单的小知识点，后面详细介绍 &gt;在Python2 中有经典类与新式类之分，<br />在Python3 中全都为新式类</p><p>我们现在用的主流是Python3 ，而Python3 中全都是新式类，所以在Python3中没必要考虑这个，但是我们也需要知道Python2中是怎么用的，具体怎么区分我们后面会详细讲到，现在大家先知道这个概念</p><h3 id="如何寻找继承关系">如何寻找继承关系</h3><p>继承是类与类之间的关系，寻找这种继承关系需要先抽象，再具体。什么是抽象呢？就是抽取比较像的部分呀，我们刚学面向对象的时候就是抽取对象中相似的特征总结成了类 ，那么抽取类与类之间相似的地方就总结成了父类</p><figure><img src= "img/ballloading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2019/png/281865/1554567518337-6842e3a3-a76b-4194-a9fb-e3db20053013.png#align=left&amp;display=inline&amp;height=375&amp;originHeight=345&amp;originWidth=720&amp;size=0&amp;status=done&amp;width=782?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_5L2c6ICF77ya6ams5LiA54m5%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>这个图很明白，不同的人抽象成人类，人狗猪又可以抽象成动物类，抽象完了之后，继承关系就有了，人狗猪都是继承来自动物，他们分别实例化就能得到各自的对象</p><figure><img src= "img/ballloading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2019/png/281865/1554567518433-9cd4d7bf-c305-4d3e-b1a6-446440233ab0.png#align=left&amp;display=inline&amp;height=415&amp;originHeight=348&amp;originWidth=720&amp;size=0&amp;status=done&amp;width=858?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_5L2c6ICF77ya6ams5LiA54m5%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><p>假如现在有这样一个需求，把老师和学生，学生可以自由选择课程学习，老师可以对学生的成绩做评分，按照原来的思路，我应该这样写代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;student %s is choosing course&quot;</span> % self.name)</span><br></pre></td></tr></table></figure><p>代码写到这里你应可以发现了，这里面有重复的代码，为了避免代码冗余，我们应该使用继承的方式来优化我们的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;student %s is choosing course&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;张二狗&quot;</span>, <span class="number">18</span>, <span class="string">&quot;female&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们在执行代码实例化对象之前，先来看一下代码里面老师类和学生类里面都没有init这个实例化函数，但是程序没有报错说明他确实完成实例化了，怎么证明呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(tea1.name, tea1.age, tea1.gender)</span><br></pre></td></tr></table></figure><pre><code>albert 18 male</code></pre><p>这就说明了子类中没有init函数，他就会去父类中找，也就是说子类是继承了父类的属性，到此为止，你就会发现我们的代码已经精简了，但是他实现的功能并没有减少</p><h3 id="属性查找">属性查找</h3><p>有了继承关系以后，接下来我们再来说属性的查找，之前我们说过一个对象查找属性的时候，优先去自己的名称空间中查找，如果找不到就会去自己的类中去找，但是现在你会发现类中居然还有自己的父类，那你试想一下，如果一个对象他自己的名称空间中没有，他的类也没有，那接下来应该找谁？</p><p>没错，找他爹，如果他的父类没有并且再有父类呢？找他爷爷</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">print(tea1.__dict__)</span><br><span class="line">print(tea1.name)</span><br><span class="line">print(DeepshareTeacher.__dict__)</span><br><span class="line">print(DeepsharePeople.__dict__)</span><br><span class="line">print(tea1.school)</span><br></pre></td></tr></table></figure><pre><code>&#123;&#39;name&#39;: &#39;albert&#39;, &#39;age&#39;: 18, &#39;gender&#39;: &#39;male&#39;&#125;albert&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;modify_score&#39;: &lt;function DeepshareTeacher.modify_score at 0x00000127D2952288&gt;, &#39;__doc__&#39;: None&#125;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;school&#39;: &#39;deepshare&#39;, &#39;__init__&#39;: &lt;function DeepsharePeople.__init__ at 0x00000127D2952828&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;DeepsharePeople&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;DeepsharePeople&#39; objects&gt;, &#39;__doc__&#39;: None&#125;deepshare</code></pre><p>从第一个和第二个print中我么可以看出，对象自己的名称空间中有，会优先找自己的名称空间，从第三四五个打印中我们可以发现，teacher对象自己名称空间中没有，会先从自己的类中找，发现自己的类中也没有，就会到他的父类中找，在他的父类中找到了，就会有结果</p><p>再来看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(tea1.modify_score)</span><br></pre></td></tr></table></figure><pre><code>&lt;bound method DeepshareTeacher.modify_score of &lt;__main__.DeepshareTeacher object at 0x00000127D294E988&gt;&gt;</code></pre><p>在对象自己的类里面直接就找到了，不再往下寻找了</p><p>接下来，我们再来看一个复杂点的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Foo.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Foo.f2&quot;</span>)</span><br><span class="line">        self.f1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params">Foo</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Bar.f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Bar()</span><br><span class="line">obj.f2()</span><br></pre></td></tr></table></figure><pre><code>Foo.f2Bar.f1</code></pre><p>输出结果，我先不贴出来，大家猜一下，再往后面看</p><p>分析：</p><p>obj是Bar的对象，他调f2方法，先从自己的名称空间中找f2属性，这肯定是没有的，因为obj我们没有给他定制自己的属性，来看一下吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(obj.__dict__)</span><br><span class="line">print(obj)</span><br><span class="line">print(Bar.__dict__)</span><br></pre></td></tr></table></figure><pre><code>&#123;&#125;&lt;__main__.Bar object at 0x00000127D293F708&gt;&#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;f1&#39;: &lt;function Bar.f1 at 0x00000127D2952558&gt;, &#39;__doc__&#39;: None&#125;</code></pre><p>那么接下来找自己的类的名称空间，自己类的名称空间没有，那就去父类Foo中找，找到了就会打印Foo.f2，这一点肯定没有问题，那么下面一行self.f1()应该打印哪个f1呢，是离他更近的Foo.f1,还是距离他较远的Bar.f1呢</p><p>这里其实与距离远近没有关系，很多同学容易误解，所以我这里就拿出做一个反响引导，当代码执行到self.f1()这一行的时候，我们先<code>要搞清楚self是谁，他就是obj这个对象</code>，按照属性查找顺序</p><blockquote><p>对象自己的名称名空间====&gt;对象所在的类的名称空间====&gt;对象的所在的类的父类的名称空间</p></blockquote><h3 id="派生">派生</h3><p>刚刚我们讲完了继承，继承的好处是子类可以重用父类的代码，但问题是子类是不是就和父类一模一样就行了，如果这样那你写子类的目的是什么呢？子类有了以子类为准，所以在这里我们再讲一个叫做派生的概念</p><p>其实这个概念本章一开始我们就提及到了，假如你爹有一套房子，你可以进去住一下，但是如果你自己有房子，肯定会优先住自己的房子</p><p>派生就是在继承的基础上有自己新的东西，如果有自己新的东西，肯定就会以自己新的东西为准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 派生：子类定义自己新的属性，如果与父类同名，以子类自己的为准</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;爹的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;儿子的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line">tea1.f1()</span><br></pre></td></tr></table></figure><pre><code>儿子的f1</code></pre><p>我们再来看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;爹的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, salary</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;儿子的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;10 &quot;</span>, <span class="string">&quot;3.1&quot;</span>)</span><br><span class="line">print(tea1.name, tea1.age, tea1.gender, tea1.level, tea1.salary)</span><br></pre></td></tr></table></figure><pre><code>albert 18 male 10  3.1</code></pre><p>tea1实例化对象的时候其实就是去他的类中找init函数，如果他自己没有那肯定是去父类中找，但是现在他自己有了，就用自己的，这就是派生的应用，在子类定制自己的属性，从而覆盖父类。子类有一些独特的功能，单独定义，有一些大家共有的在父类还能使用 。</p><p>从上面的派生中你有没有发现，我们虽然实现了功能，但是子类里面写了一些重复的代码，我们必须要把重复代码去掉，又要把证这些重复的代码还能用，这又应该怎么操作呢？</p><p>我们必须要想一个方案，在子类派生出来的方法中能够重用父类的一段功能</p><p>第一种想法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;爹的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, salary</span>):</span></span><br><span class="line">        <span class="comment"># self.name = name</span></span><br><span class="line">        <span class="comment"># self.age = age</span></span><br><span class="line">        <span class="comment"># self.gender = gender</span></span><br><span class="line">        self.__init__(name, age, gender)</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;儿子的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;10 &quot;</span>, <span class="string">&quot;3.1&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-35-fa21015d6b8d&gt; in &lt;module&gt;     27      28 ---&gt; 29 tea1 = DeepshareTeacher(&quot;albert&quot;, 18, &quot;male&quot;, &quot;10 &quot;, &quot;3.1&quot;)&lt;ipython-input-35-fa21015d6b8d&gt; in __init__(self, name, age, gender, level, salary)     16         # self.age = age     17         # self.gender = gender---&gt; 18         self.__init__(name, age, gender)     19         self.level = level     20         self.salary = salaryTypeError: __init__() missing 2 required positional arguments: &#39;level&#39; and &#39;salary&#39;</code></pre><p>我们对象自己重复调用自己的init函数，这是一个递归，执行代码发现报错了，他说少两个参数，其实我们想要调用的并不是自己，而是父类的init，用对象调已经不行了，那我们就用他的父类来调</p><p>派生第一种方案（指名道姓的调用父类）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;爹的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, salary</span>):</span></span><br><span class="line">        <span class="comment"># self.name = name</span></span><br><span class="line">        <span class="comment"># self.age = age</span></span><br><span class="line">        <span class="comment"># self.gender = gender</span></span><br><span class="line">        <span class="comment"># 用类来调用，没有自动传值，要把self写上</span></span><br><span class="line">        DeepsharePeople.__init__(self, name, age, gender)</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;儿子的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;10 &quot;</span>, <span class="string">&quot;3.1&quot;</span>)</span><br><span class="line">print(tea1.name, tea1.age, tea1.gender, tea1.level, tea1.salary)</span><br></pre></td></tr></table></figure><pre><code>albert 18 male 10  3.1</code></pre><p>到目前为止，我们已经实现了子类重用父类的功能，但是这种方式和继承有关系吗，我们是否可以指名道姓的调用一个和我们当前类没有任何继承关系的一个类呢？当然可以</p><p>下面我们在父类中添加一些东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        =====个人信息=====</span></span><br><span class="line"><span class="string">        姓名：%s</span></span><br><span class="line"><span class="string">        年龄：%s</span></span><br><span class="line"><span class="string">        性别：%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            % (self.name, self.age, self.gender)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, salary</span>):</span></span><br><span class="line">        <span class="comment"># self.name = name</span></span><br><span class="line">        <span class="comment"># self.age = age</span></span><br><span class="line">        <span class="comment"># self.gender = gender</span></span><br><span class="line">        DeepsharePeople.__init__(self, name, age, gender)</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;儿子的f1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;10 &quot;</span>, <span class="string">&quot;3.1&quot;</span>)</span><br><span class="line">tea1.info()</span><br></pre></td></tr></table></figure><pre><code>        =====个人信息=====        姓名：albert        年龄：18        性别：male</code></pre><p>​</p><p>teacher还有自己等级和薪资，那么我们再来在子类中添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        =====个人信息=====</span></span><br><span class="line"><span class="string">        姓名：%s</span></span><br><span class="line"><span class="string">        年龄：%s</span></span><br><span class="line"><span class="string">        性别：%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            % (self.name, self.age, self.gender)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, salary</span>):</span></span><br><span class="line">        <span class="comment"># self.name = name</span></span><br><span class="line">        <span class="comment"># self.age = age</span></span><br><span class="line">        <span class="comment"># self.gender = gender</span></span><br><span class="line">        DeepsharePeople.__init__(self, name, age, gender)</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        =====个人信息=====</span></span><br><span class="line"><span class="string">        姓名：%s</span></span><br><span class="line"><span class="string">        年龄：%s</span></span><br><span class="line"><span class="string">        性别：%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            % (self.name, self.age, self.gender)</span><br><span class="line">        )</span><br><span class="line">        print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        等级：%s</span></span><br><span class="line"><span class="string">        薪资：%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            % (self.level, self.salary)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;10 &quot;</span>, <span class="string">&quot;3.1&quot;</span>)</span><br><span class="line">tea1.info()</span><br></pre></td></tr></table></figure><pre><code>        =====个人信息=====        姓名：albert        年龄：18        性别：male</code></pre><p>​<br />等级：10 薪资：3.1</p><p>​</p><p>依然有代码重复，如法炮制，他们的原理是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        =====个人信息=====</span></span><br><span class="line"><span class="string">        姓名：%s</span></span><br><span class="line"><span class="string">        年龄：%s</span></span><br><span class="line"><span class="string">        性别：%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            % (self.name, self.age, self.gender)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, salary</span>):</span></span><br><span class="line">        <span class="comment"># self.name = name</span></span><br><span class="line">        <span class="comment"># self.age = age</span></span><br><span class="line">        <span class="comment"># self.gender = gender</span></span><br><span class="line">        DeepsharePeople.__init__(self, name, age, gender)</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 注意：用类去掉不会自动传self，需要我们手动写一下</span></span><br><span class="line">        DeepsharePeople.info(self)</span><br><span class="line">        print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        等级：%s</span></span><br><span class="line"><span class="string">        薪资：%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            % (self.level, self.level)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;10 &quot;</span>, <span class="string">&quot;3.1&quot;</span>)</span><br><span class="line">tea1.info()</span><br></pre></td></tr></table></figure><pre><code>        =====个人信息=====        姓名：albert        年龄：18        性别：male</code></pre><p>​<br />等级：10 薪资：10</p><p>​</p><p>派生第二种方案（用super( )调用）： &gt;super（）的返回值是一个特殊的对象，该对象专门用来调用父类中的属性</p><p>我们用super来修改我们的代码</p><p>super的调用与第一种派生方式不同，他是严格依赖继承关系，这两种方式都可以使用，没有谁好谁坏，但是两种方式千万不要混合使用，那谁也救不了你啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        =====个人信息=====</span></span><br><span class="line"><span class="string">        姓名：%s</span></span><br><span class="line"><span class="string">        年龄：%s</span></span><br><span class="line"><span class="string">        性别：%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            % (self.name, self.age, self.gender)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, salary</span>):</span></span><br><span class="line">        <span class="comment"># self.name = name</span></span><br><span class="line">        <span class="comment"># self.age = age</span></span><br><span class="line">        <span class="comment"># self.gender = gender</span></span><br><span class="line">        <span class="comment"># DeepsharePeople.__init__(self,name,age,gender )</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age, gender)  <span class="comment"># 这里调用的是父类的init，super()是一个对象</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is modifying score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># DeepsharePeople.info(self)</span></span><br><span class="line">        <span class="built_in">super</span>().info()  <span class="comment"># 同理，super()返回值是一个对象，不要self，调用的info是父类的info</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        等级：%s</span></span><br><span class="line"><span class="string">        薪资：%s</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">            % (self.level, self.level)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;10 &quot;</span>, <span class="string">&quot;3.1&quot;</span>)</span><br><span class="line">tea1.info()</span><br></pre></td></tr></table></figure><pre><code>        =====个人信息=====        姓名：albert        年龄：18        性别：male</code></pre><p>​<br />等级：10 薪资：10</p><p>​</p><h3 id="经典类与新式类">经典类与新式类</h3><p>一开始的时候我们就引出了这个概念，现在我们来理解一下 &gt;新式类：继承object的类，以及该类的子类孙子类，都是新式类<br />经典类：没有继承object的类，以及该类的子类，孙子类，都是经典类</p><h3 id="多继承属性查找">多继承属性查找</h3><p>我们了解了经典类与新式类，接下里我们要清楚他们的区别在哪里，区别就是在属性查找上，我们知道Python支持多继承，我们之前研究的都是单继承，接下来我们就来研究多继承。</p><p>先说一下结论，请看下图，当继承关系为菱形结构，那么属性查找的方式有两种，分别是深度优先和广度优先</p><figure><img src= "img/ballloading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/BassMio/PicGO/2021/5/%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>注意：</p><p>只有当继承关系组成一个菱形结构，也就是最后至少有两个类都继承了同一个类，这时才会区分经典类与新式类，也就是说如果EFD这三个类中只有一个类或者没有类继承G类，那就不是菱形结构，他的继承关系属性查找就是从左到右，B=&gt;E=&gt;（G=&gt;）C=&gt;F=&gt;D，在这一点上新式类与经典类没有区别，</p><p>当继承关系是菱形结构时，深度优先就是一条道走到黑，B=&gt;E=&gt;G=&gt;C=&gt;F=&gt;D</p><p>广度优先就是先试探再迂回， B=&gt;E=&gt;C=&gt;F=&gt;D=&gt;G</p><p>这个是Python内部的实现机制，它使用的是C3算法去计算出来的多继承属性查找</p><figure><img src= "img/ballloading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/BassMio/PicGO/2021/5/%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE2" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;from A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;from B&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;from C&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;from D&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>(<span class="params">C</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;from E&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span>(<span class="params">D, E</span>):</span></span><br><span class="line">    <span class="comment">#     def test(self):</span></span><br><span class="line">    <span class="comment">#         print(&#x27;from F&#x27;)</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = F()</span><br><span class="line">f1.test()</span><br></pre></td></tr></table></figure><pre><code>from D</code></pre><p>在这里我们就不花费大量的篇幅去验证了，大家可以自己去验证一下，另外补充一点，在新式类中，专门提供了一个属性查找方法<code>mro</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1 = F()</span><br><span class="line">f1.test()</span><br><span class="line">print(F.__mro__)</span><br><span class="line">print(F.mro())</span><br></pre></td></tr></table></figure><pre><code>from D(&lt;class &#39;__main__.F&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)[&lt;class &#39;__main__.F&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre><p>他会以列表或者元祖的形式保存查找顺序，因为这种数据类型都是有顺序的</p><h3 id="super-继承查找">super( )继承查找</h3><p>接下来是super()对象继承查找的特殊之处，如果代码是这样的，那么自然是没有问题的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;XF&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;1 打印一下，代码先经过这里&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().f1()</span><br><span class="line">        print(<span class="string">&quot;3 再打印一下，代码最后经过这里&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;2 再经过这里from B&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.test()</span><br><span class="line">print(C.mro())</span><br></pre></td></tr></table></figure><pre><code>1 打印一下，代码先经过这里XF3 再打印一下，代码最后经过这里[&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.X&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre><p>但是如果是有super()对象参与进来的继承查找，super()所继承的类并没有该方法(object类或者上面代码的X类都可以)，这时mro列表的继承顺序会和我们理解的有冲突，继承顺序会严格按照mro列表从当前查找到的位置继续往后查找，mro方法认为，只要有与当前类平级的类中有他需要查找的方法，那就不管那么多了，认爹吧，所以：即使A与B之间本没有直接的继承关系，A也会把B当成爹，最后再回到当前位置，继续往下执行代码，就像是中了super()的毒一样，而不是按照我们原本的理解，寻找super()对象的test方法，找不到然后找它的父类object类或者X类，然后报错。</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>:</span>  <span class="comment"># X类没有也是一样的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># def f1(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;XF&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;1 打印一下，代码先经过这里&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().f1()</span><br><span class="line">        print(<span class="string">&quot;3 再打印一下，代码最后经过这里&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;2 再经过这里from B&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.test()</span><br><span class="line">print(C.mro())</span><br></pre></td></tr></table></figure><pre><code>1 打印一下，代码先经过这里2 再经过这里from B3 再打印一下，代码最后经过这里[&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.X&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;object&#39;&gt;]</code></pre><p>在子类中重用父类的方法我们知道两种方式：一种是指名道姓的调用父类，另外一种是用super，这两种方式哪种好其实在Python社区的争论一直都有，各有优略，super其实查找一个属性并不够明确， 而另外一种指名道姓的方式你立马就能看出来调用的是哪个类里面的东西，但这种方式却又和继承关系不大 。所以，以后还是用哪一种都可以，但是别混着用。</p><h3 id="组合">组合</h3><p>严格来讲，其实组合与继承并没有直接的关系，但是组合和继承都是解决类与类之间代码冗余的方案，站在面向对象的角度考虑他们是同一类，所以我们这里放在一起来讲。区别是继承描述的是类与类之间的从属关系，也就是什么是什么的关系，而组合描述的是类与类之间的交叉关系，也就是什么有什么的关系<br />&gt;一个类产生的对象，该对象拥有一个属性，这个属性的值是来自于另外一个类的对象</p><p>依然是我们前面的老师阅读学生的代码，我希望老师对象能够有出生日期这个属性，学生对象也有这个属性，这应该怎么操作呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, year, mon, day</span>):</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.mon = mon</span><br><span class="line">        self.day = day</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_birth</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;出生年月日&lt;%s-%s-%s&gt;&quot;</span> % (self.year, self.mon, self.day))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepsharePeople</span>:</span></span><br><span class="line">    school = <span class="string">&quot;deepshare&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareTeacher</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, salary</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age, gender)</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;teacher %s is changing score&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepshareStudent</span>(<span class="params">DeepsharePeople</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self, name, age, gender, course,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(</span><br><span class="line">            name, age, gender,</span><br><span class="line">        )</span><br><span class="line">        self.course = course</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;student %s choose course&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tea1 = DeepshareTeacher(<span class="string">&quot;albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="number">10</span>, <span class="number">3.1</span>)</span><br><span class="line">date_obj = Date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">date_obj.tell_birth()</span><br><span class="line"></span><br><span class="line">tea1.birth = date_obj</span><br><span class="line">print(tea1.birth)</span><br><span class="line"></span><br><span class="line">tea1.birth.tell_birth()</span><br><span class="line">tea1.change_score()</span><br><span class="line">stu1 = DeepshareStudent(<span class="string">&quot;张三&quot;</span>, <span class="number">16</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;AI&quot;</span>)</span><br><span class="line">stu1.birth = Date(<span class="number">2002</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">stu1.birth.tell_birth()</span><br></pre></td></tr></table></figure><pre><code>出生年月日&lt;2000-1-1&gt;&lt;__main__.Date object at 0x00000127D29A8848&gt;出生年月日&lt;2000-1-1&gt;teacher albert is changing score出生年月日&lt;2002-3-3&gt;</code></pre><p>到这里我们会发现解决代码重用问题会有两种方案，一种叫继承，一种叫组合，所以在我们本周的项目中会大量的使用组合，因为从软件设计的角度来考虑，使用组合其实会比继承更好，</p><p>就刚才的场景来说继承也能实现， 但是继承相当于是类与类之间做了一种强耦合，而组合实质上是一种解耦合，在工作中考虑到软件的可拓展性，代码的耦合性越高，越不利于拓展 。当然继承依然是必不可少的，在后面的课程内容中，我们会带领大家去解读一些Python写的经典的源码，里面会大量的使用组合与继承，这一章节非常重要，所以我花费了大量的篇幅去讲解。</p><h1 id="函数概述">函数概述</h1><h2 id="函数的定义与调用说明">函数的定义与调用说明</h2><p>需要注意的是，函数名本质和变量类似(打印一个变量你直接看到的结果是变量的值，这是龟叔在内部做了转化，为了让你看的更直观，<code>打印函数你直接看到的结果是一个内存地址</code>，从底层上讲，<code>变量名与函数名其实都是与内存地址对应的</code>，因为定义的过程就是在开辟内存空间)，所以函数名定义规则与定义变量名一致。函数就像是一个功能，这个功能就是要执行一个动作，所以约定俗成写成动词或者动词词组。 具备某一个功能的工具就是程序中的函数<br />事先准备工具的过程就是函数的定义<br />把准备好的工具拿来就用即为函数的调用</p><blockquote><p>所以函数的使用必须遵循：先定义，再调用</p></blockquote><h2 id="函数的定义">函数的定义</h2><h3 id="定义函数的三种形式">定义函数的三种形式：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 有参函数：当函数体的功能依赖于传入的参数时，我们就使用有参函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max2</span>(<span class="params">x, y</span>):</span>  <span class="comment"># x=100,y=101</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        print(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">max2(<span class="number">100</span>, <span class="number">101</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 无参函数：当函数体的功能不使用传入的参数时，我们传入参数显然是没有必要的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;---soft run-----------&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interact</span>():</span></span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;username&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">    pwd = <span class="built_in">input</span>(<span class="string">&quot;password&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">    print(name, pwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interact()  <span class="comment"># 定义时无参，意味着调用时也无须传入参数</span></span><br><span class="line">func()  <span class="comment"># 定义时无参，意味着调用时也无须传入参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 空函数:函数体为pass，事先定义功能组织结构，通过调用函数执行某个功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">username, password</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这是一个用户认证功能，在Pycharm中，当输入三引号回撤之后，下面的三行代码自动出现</span></span><br><span class="line"><span class="string">    :param username: </span></span><br><span class="line"><span class="string">    :param password: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    上传功能</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    下载功能</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ls</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    list contents</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><pre><code>101username&gt;&gt;:  password&gt;&gt;:  </code></pre><p>​<br />---------------------- ---soft run----------- ----------------------</p><h2 id="函数的调用">函数的调用</h2><h3 id="函数调用说明">函数调用说明</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的使用必须遵循：先定义，后调用的原则</span></span><br><span class="line"><span class="comment"># 注意：如果没有事先定义函数而直接调用，就相当于在引用一个不存在的变量名</span></span><br><span class="line"><span class="comment"># 定义阶段：在定义阶段只检测语法，不执行函数体代码</span></span><br><span class="line"><span class="comment"># 调用阶段：根据函数名找到函数的内存地址，然后执行函数体代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名加括号即调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义阶段</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">&quot;from foo&quot;</span>)</span><br><span class="line">    bar()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    print(<span class="string">&quot;from bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用阶段</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">会报错</span></span><br><span class="line"><span class="string"># 定义阶段</span></span><br><span class="line"><span class="string">def foo():</span></span><br><span class="line"><span class="string">    print(&#x27;from foo&#x27;)</span></span><br><span class="line"><span class="string">    bar()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 调用阶段</span></span><br><span class="line"><span class="string">foo()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def bar():</span></span><br><span class="line"><span class="string">    print(&#x27;from bar&#x27;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><pre><code>from foofrom bar&quot;\n会报错\n# 定义阶段\ndef foo():\n    print(&#39;from foo&#39;)\n    bar()\n\n\n# 调用阶段\nfoo()\n\n\ndef bar():\n    print(&#39;from bar&#39;)\n&quot;</code></pre><h3 id="调用函数的三种形式">调用函数的三种形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 基本的调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&quot;from func&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 调用并把返回结果赋值给变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max2</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = max2(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">print(res)</span><br><span class="line">res = max2(<span class="number">10</span>, <span class="number">3</span>) * <span class="number">100</span>  <span class="comment"># 和上面类似，对返回结果再计算</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 把返回结果再当做参数传入</span></span><br><span class="line">res = max2(max2(<span class="number">10</span>, <span class="number">3</span>), <span class="number">11</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><pre><code>from func10100011</code></pre><h2 id="函数的返回值">函数的返回值</h2><h3 id="函数返回值的三种形式">函数返回值的三种形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 没有return，或者return后面什么都不写，返回值None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = func()</span><br><span class="line">res1 = func1()</span><br><span class="line">res2 = func2()</span><br><span class="line">print(res)</span><br><span class="line">print(res1)</span><br><span class="line">print(res2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 return后跟一个值,返回该值本身</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res3 = func3()</span><br><span class="line">print(res3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 return可以逗号分隔，返回多个值,会返回一个元组给调用者</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func4</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res4 = func4()</span><br><span class="line">print(res4)  <span class="comment"># (1, 2, [1, 2, 3])</span></span><br></pre></td></tr></table></figure><pre><code>NoneNoneNone1(1, 2, [1, 2, 3])</code></pre><h3 id="return两点注意事项">return两点注意事项</h3><ul><li>return返回值没有类型限制<br /></li><li>return是函数结束的标志，函数内可以写多个return，但执行一次，函数就立刻结束，并把return后的值作为本次调用的返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func5</span>():</span></span><br><span class="line">    print(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;second&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">&quot;third&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res5 = func5()</span><br><span class="line">print(res5)</span><br></pre></td></tr></table></figure><pre><code>first1</code></pre><h2 id="函数的参数">函数的参数</h2><h3 id="形参与实参">形参与实参</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">形参（形式参数）：指的是在定义函数时，括号内定义的参数，形参其实就变量名</span></span><br><span class="line"><span class="string">实参（实际参数）：指的是在调用函数时，括号内传入的值，实参其实就是变量的值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># x,y是形参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x, y</span>):</span>  <span class="comment"># x=10, y=11</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10,11是实参</span></span><br><span class="line">func(<span class="number">10</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意：</span></span><br><span class="line"><span class="string">实参值（变量的值）与形参（变量名）的绑定关系只在函数调用时才会生效/绑定</span></span><br><span class="line"><span class="string">在函数调用结束后就立刻解除绑定</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><pre><code>1011&#39;\n注意：\n实参值（变量的值）与形参（变量名）的绑定关系只在函数调用时才会生效/绑定\n在函数调用结束后就立刻解除绑定\n&#39;</code></pre><h3 id="有参函数的五种传参方式">有参函数的五种传参方式</h3><h4 id="位置参数">位置参数</h4><p>以上所讲的形参与实参是有参函数的两个概念，接下是传参方式，位置参数就是最基本的传参方式。位置即顺序，位置参数指的就是按照从左到右的顺序依次定义的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在定义函数时，按照位置定义的形参，称为位置形参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y, z</span>):</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意：</span></span><br><span class="line"><span class="string">位置形参的特性是：在调用函数时必须为其传值，而且多一个不行，少一个也不行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在调用函数时，按照位置定义的实参，称为位置实参</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo(1,2) # 报错</span></span><br><span class="line"><span class="comment"># foo(1,2,3,4) #报错</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>)  <span class="comment"># x = 1, y = 3, z = 2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意：位置实参会与形参一一对应</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><pre><code>1 3 2&#39;\n注意：位置实参会与形参一一对应\n&#39;</code></pre><h4 id="关键字参数">关键字参数</h4><p>在调用函数时，按照key=value的形式定义的实参，称为关键字参数。关键字参数是指在位置形参的前提下，以关键字的形式为形参传值，所以它与位置参数的区别主要是体现在实参的传值上面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y, z</span>):</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意：</span></span><br><span class="line"><span class="string">1 相当于直呼其名的为形参传值，意味着即便是不按照顺序定义，仍然能为指定的参数传值</span></span><br><span class="line"><span class="string">foo(2,1,3)  # x=2,y=1,z=3</span></span><br><span class="line"><span class="string">foo(y=2,x=1,z=3)  # x=1,y=2,z=3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2 在调用函数时，位置实参与关键字实参可以混合使用，但必须遵循形参的规则 </span></span><br><span class="line"><span class="string">foo(1,z=3)  # 报错</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3 不能为同一个形参重复传值</span></span><br><span class="line"><span class="string">foo(1,x=1,y=3,z=2)  # 报错</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4 位置实参必须放到关键字实参的前面</span></span><br><span class="line"><span class="string">foo(y=3,z=2,1)  # 报错</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, z=<span class="number">3</span>, y=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><pre><code>1 2 3</code></pre><h4 id="默认参数">默认参数</h4><p>到目前形参只讲了一种就是位置形参，实参讲了两种分别是位置实参和关键字实参，接下来我们再来讲解一种形参，叫做默认参数。它指的是在定义阶段已经为某个形参赋值,那么该形参就称为默认参数 &gt; 默认参数的值应该设置为不可变类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 定义阶段已经有值,意味着调用阶段可以不传值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name, age, sex=<span class="string">&quot;male&quot;</span></span>):</span></span><br><span class="line">    print(name, age, sex)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">register(</span><br><span class="line">    <span class="string">&quot;Albert&quot;</span>, <span class="number">18</span>,</span><br><span class="line">)</span><br><span class="line">register(</span><br><span class="line">    <span class="string">&quot;James&quot;</span>, <span class="number">34</span>,</span><br><span class="line">)</span><br><span class="line">register(<span class="string">&quot;林志玲&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>)</span><br><span class="line">register(<span class="string">&quot;周星驰&quot;</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 位置形参必须在默认参数的前面</span></span><br><span class="line"><span class="comment"># def func(y=1,x): #报错</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 默认参数的值只在定义阶段赋值一次,也就是说默认参数的值再定义阶段就固定死了</span></span><br><span class="line">m = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y=m</span>):</span></span><br><span class="line">    print(x, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = <span class="string">&quot;a&quot;</span>  <span class="comment"># foo内的默认参数不会发生改变</span></span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 默认参数的值应该设置为不可变类型(重要)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如默认参数不是不可变类型，我们以列表为例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name, hobby, l=[]</span>):</span></span><br><span class="line">    l.append(hobby)</span><br><span class="line">    print(name, l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">register(<span class="string">&quot;Kobe&quot;</span>, <span class="string">&quot;play&quot;</span>)  <span class="comment"># Kobe [&#x27;play&#x27;] 一切正常~</span></span><br><span class="line">register(<span class="string">&quot;James&quot;</span>, <span class="string">&quot;read&quot;</span>)  <span class="comment"># James [&#x27;play&#x27;, &#x27;read&#x27;] what?!</span></span><br><span class="line">register(<span class="string">&quot;Albert&quot;</span>, <span class="string">&quot;music&quot;</span>)  <span class="comment"># Albert [&#x27;play&#x27;, &#x27;read&#x27;, &#x27;music&#x27;] 这就是未设置为不可变类型出现的BUG</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据出错的原因就是每次调用都会在同一个列表上作修改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了实现同样的功能，修正后如下</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name, hobby, l=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> l <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        l = []</span><br><span class="line">    l.append(hobby)</span><br><span class="line">    print(name, l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">register(<span class="string">&quot;Kobe&quot;</span>, <span class="string">&quot;play&quot;</span>)</span><br><span class="line">register(<span class="string">&quot;James&quot;</span>, <span class="string">&quot;read&quot;</span>)</span><br><span class="line">register(<span class="string">&quot;Albert&quot;</span>, <span class="string">&quot;music&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用场景:</span></span><br><span class="line"><span class="comment"># 对于经常需要变化的值,需要将对应的形参定义成位置形参</span></span><br><span class="line"><span class="comment"># 对于大多数情况值都一样的情况,需要将对应的形参定义成默认参数</span></span><br></pre></td></tr></table></figure><pre><code>Albert 18 maleJames 34 male林志玲 20 female周星驰 50 male1 101 11Kobe [&#39;play&#39;]James [&#39;play&#39;, &#39;read&#39;]Albert [&#39;play&#39;, &#39;read&#39;, &#39;music&#39;]Kobe [&#39;play&#39;]James [&#39;read&#39;]Albert [&#39;music&#39;]</code></pre><h4 id="可变长参数">可变长参数</h4><h5 id="可变长参数基本使用">可变长参数基本使用</h5><p>可变长度指的参数的个数可以不固定，实参有按位置定义的实参和按关键字定义的实参,所以可变长的实参指的就是按照这两种形式定义的实参个数可以不固定，然而实参终究是要给形参传值的，所以形参必须有两种对应的解决方案来分别处理以上两种形式可变长度的实参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *会将溢出的位置实参全部接收,然后保存成元组的形式赋值给一个变量args(可以任意命名，约定俗成args)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y, z, *args</span>):</span>  <span class="comment"># args=(4,5,6,7,8)</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># **会将溢出的关键字实参全部接收,然后保存成字典的形式赋值给kwargs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y, z, **kwargs</span>):</span>  <span class="comment"># kwargs=&#123;&#x27;c&#x27;:3,&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(x=<span class="number">1</span>, y=<span class="number">2</span>, z=<span class="number">3</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><pre><code>1 2 3(4, 5, 6, 7, 8)1 2 3&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</code></pre><h5 id="星与星星打散">星与星星(打散)</h5><p>很多时候【*】的作用就是打散，在讲列表的方法append与extend的区别时，也做了一个简单的说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一旦碰到实参加*,就把该实参的值打散</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y, z, *args</span>):</span>  <span class="comment"># args=([4,5,6,7,8],)</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, *[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])  <span class="comment"># foo(1,2,3,4,5,6,7,8)</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, *(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>))  <span class="comment"># foo(1,2,3,4,5,6,7,8)</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, *<span class="string">&quot;hello&quot;</span>)  <span class="comment"># foo(1,2,3,&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y, z</span>):</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo(*[1, 2, 3, 4])  # foo(1,2,3,4) #报错</span></span><br><span class="line"><span class="comment"># foo(*[1, 2, ])  # foo(1,2,) #报错</span></span><br><span class="line">foo(*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># foo(1,2,3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一旦碰到实参加**,就把该实参的值打散</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">x, y, z, **kwargs</span>):</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bar(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, **&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># foo(1,2,3,b=2,a=1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boo</span>(<span class="params">x, y, z</span>):</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># boo(1, **&#123;&#x27;z&#x27;: 3, &#x27;y&#x27;: 2, &#x27;x&#x27;: 111&#125;)  # 报错 boo(1,z=3,y=2,x=111)</span></span><br><span class="line">boo(<span class="number">1</span>, **&#123;<span class="string">&quot;z&quot;</span>: <span class="number">3</span>, <span class="string">&quot;y&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># foo(1,z=3,y=2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *的应用场景</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span>(<span class="params">*args</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> args:</span><br><span class="line">        res += num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sum2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ** 的应用场景</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">name, pwd, **kwargs</span>):</span></span><br><span class="line">    print(name)</span><br><span class="line">    print(pwd)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth(name=<span class="string">&quot;Albert&quot;</span>, pwd=<span class="string">&quot;123&quot;</span>)</span><br><span class="line">auth(name=<span class="string">&quot;Albert&quot;</span>, pwd=<span class="string">&quot;123&quot;</span>, group=<span class="string">&quot;group1&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>1 2 3(4, 5, 6, 7, 8)1 2 3(4, 5, 6, 7, 8)1 2 3(&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;)1 2 31 2 3&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;1 2 328Albert123&#123;&#125;Albert123&#123;&#39;group&#39;: &#39;group1&#39;&#125;</code></pre><h5 id="组合使用重点">组合使用(重点)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">name, age, gender</span>):</span></span><br><span class="line">    print(<span class="string">&quot;welcome %s %s %s&quot;</span> % (name, age, gender))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span>  <span class="comment"># args=(1,2,3),kwargs=&#123;&#x27;x&#x27;:1,&#x27;y&#x27;:2,&#x27;z&#x27;:3&#125;</span></span><br><span class="line">    <span class="comment"># print(args)</span></span><br><span class="line">    <span class="comment"># print(kwargs)</span></span><br><span class="line">    index(</span><br><span class="line">        *args, **kwargs</span><br><span class="line">    )  <span class="comment"># index(*(1,2,3),**&#123;&#x27;x&#x27;:1,&#x27;y&#x27;:2,&#x27;z&#x27;:3&#125;) # index(1,2,3,z=3,y=2,x=2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># wrapper(1,2,3,x=1,y=2,z=3)  # 报错</span></span><br><span class="line"></span><br><span class="line">wrapper(name=<span class="string">&quot;Albert&quot;</span>, age=<span class="number">18</span>, gender=<span class="string">&quot;male&quot;</span>)</span><br><span class="line">wrapper(<span class="string">&quot;Albert&quot;</span>, age=<span class="number">18</span>, gender=<span class="string">&quot;male&quot;</span>)</span><br><span class="line">wrapper(<span class="string">&quot;Albert&quot;</span>, <span class="number">18</span>, gender=<span class="string">&quot;male&quot;</span>)</span><br><span class="line">wrapper(<span class="string">&quot;Albert&quot;</span>, <span class="number">18</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">执行过程：</span></span><br><span class="line"><span class="string">wrapper的所有参数都原封不动地传给index，而index函数只接收三个位置参数</span></span><br><span class="line"><span class="string">星与星星的组合使用在源码中非常常见，这也是装饰器的核心之一，这非常重要。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><pre><code>welcome Albert 18 malewelcome Albert 18 malewelcome Albert 18 malewelcome Albert 18 male&#39;\n执行过程：\nwrapper的所有参数都原封不动地传给index，而index函数只接收三个位置参数\n星与星星的组合使用在源码中非常常见，这也是装饰器的核心之一，这非常重要。\n&#39;</code></pre><h4 id="命名关键字参数">命名关键字参数</h4><h5 id="命名关键字参数导入">命名关键字参数导入</h5><p>在【星】后面参数都是命名关键字参数，它的特点是必须被传值，约束函数的调用者必须按照key=value的形式传值，约束函数的调用者必须用指定的key名。</p><p>如果没有命名关键字参数，当我们需要在做上述约束时，应该按照如下代码操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用方式auth(name=&quot;Albert&quot;,pwd=&quot;123&quot;)</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&quot;必须用关键字的形式传参&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;name&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        print(<span class="string">&quot;必须用指定的key名name&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;pwd&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> kwargs:</span><br><span class="line">        print(<span class="string">&quot;必须用指定的key名pwd&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    name = kwargs[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">    pwd = kwargs[<span class="string">&quot;pwd&quot;</span>]</span><br><span class="line">    print(name, pwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">help</span>(auth))  <span class="comment"># 打印文档注释</span></span><br><span class="line"></span><br><span class="line">auth(x=<span class="string">&quot;Albert&quot;</span>, y=<span class="string">&quot;123&quot;</span>)</span><br><span class="line">auth(<span class="string">&quot;Albert&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">auth(<span class="string">&quot;Albert&quot;</span>, pwd=<span class="string">&quot;123&quot;</span>)</span><br><span class="line">auth(name=<span class="string">&quot;Albert&quot;</span>, pwd=<span class="string">&quot;123&quot;</span>)  <span class="comment"># 约束函数的调用者必须用key=value的形式传值</span></span><br></pre></td></tr></table></figure><pre><code>Help on function auth in module __main__:auth(*args, **kwargs)    使用方式auth(name=&quot;Albert&quot;,pwd=&quot;123&quot;)    :param args:    :param kwargs:    :return:None必须用指定的key名name必须用关键字的形式传参必须用关键字的形式传参Albert 123</code></pre><h5 id="命名关键字参数使用">命名关键字参数使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用命名关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y, *, z</span>):</span></span><br><span class="line">    print(x, y, z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo(1,2)  # 报错</span></span><br><span class="line"><span class="comment"># foo(1,2,3)  # 报错</span></span><br><span class="line"><span class="comment"># foo(1,2,a=3)  # 报错</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实命名关键字参数的核心是 *，args只是一个变量，有或者没有并不影响</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">*args, name, pwd</span>):</span></span><br><span class="line">    print(name, pwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">auth(pwd=<span class="string">&quot;123&quot;</span>, name=<span class="string">&quot;Albert&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名关键字参数是硬性限制，但Python的语法风格是约定俗成，不做限制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name, age</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    我们不会在这里添加对name和age的要求限制</span></span><br><span class="line"><span class="string">    :param name: </span></span><br><span class="line"><span class="string">    :param age: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="built_in">type</span>(name), <span class="built_in">type</span>(age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">register(<span class="number">123</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命名关键字参数之后，可以接收参数的最复杂的情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x, y=<span class="number">1</span>, *args, z, m=<span class="number">2</span>, **kwargs</span>):</span>  <span class="comment"># m=2是关键字参数的默认值</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般情况下，foo1和foo2这两种就够用了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span>(<span class="params">x, y=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo2</span>(<span class="params">x, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><pre><code>1 2 3Albert 123&lt;class &#39;int&#39;&gt; &lt;class &#39;list&#39;&gt;</code></pre><h1 id="闭包函数">闭包函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;from func1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">        print(<span class="string">&quot;from func2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(func2)</span><br><span class="line">    func2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line"><span class="comment"># print(func2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># 函数在定义阶段不执行函数体内的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    print(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        print(<span class="string">&quot;f2&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">            print(<span class="string">&quot;f3&quot;</span>)</span><br><span class="line"></span><br><span class="line">        f3()</span><br><span class="line"></span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><pre><code>from func1&lt;function func1.&lt;locals&gt;.func2 at 0x00000271D6DE7318&gt;from func2f1f2f3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本四(使用闭包函数，不修改源函数调用方式)</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;welcome to index page&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">func</span>):</span>  <span class="comment"># func=最原始的index</span></span><br><span class="line">    <span class="comment"># func=最原始的index</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(stop_time - start_time)</span><br><span class="line">        print(wrapper)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># a = outer(index)  # outer函数结果可以赋值给任意变量</span></span><br><span class="line"><span class="comment"># b = outer(index)</span></span><br><span class="line"><span class="comment"># c = outer(index)</span></span><br><span class="line">print(index)</span><br><span class="line">index = outer(index)  <span class="comment"># 赋值给index覆盖原来的index，index = wrapper</span></span><br><span class="line">index()  <span class="comment"># wrapper()</span></span><br><span class="line">print(index)</span><br></pre></td></tr></table></figure><pre><code>&lt;function index at 0x00000271D82B7558&gt;welcome to index page3.014785051345825&lt;function outer.&lt;locals&gt;.wrapper at 0x00000271D7F16DC8&gt;&lt;function outer.&lt;locals&gt;.wrapper at 0x00000271D7F16DC8&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本五(解决原函数返回值无效)</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;welcome to index page&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 假如源函数有一个返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># func=最原始的home</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = func()  <span class="comment"># 调用最原始的index</span></span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(stop_time - start_time)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index = outer(index)  <span class="comment"># 新的index=wrapper</span></span><br><span class="line">nres = index()  <span class="comment"># 上一个版本返回值为None</span></span><br><span class="line">print(nres)</span><br></pre></td></tr></table></figure><pre><code>welcome to index page1.01167106628417971</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器也是一个函数，使用函数必先定义，所以装饰器放在最上方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(stop_time - start_time)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer  </span><span class="comment"># 在被装饰对象正上方单独一行添加，相当于执行index=timer(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span>  <span class="comment"># 此时index = wrapper</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;welcome to index page&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @timer  # home=timer(home) 当不需要装饰器的时候只需注释这一行即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;welcome %s to home page&quot;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index()</span><br><span class="line"><span class="comment"># home(&quot;Albert&quot;)</span></span><br><span class="line">print(index)</span><br></pre></td></tr></table></figure><pre><code>welcome to index page1.0019211769104004&lt;function timer.&lt;locals&gt;.wrapper at 0x000001F25CCA68B8&gt;</code></pre><h1 id="迭代生成">迭代生成</h1><h2 id="迭代器">迭代器</h2><h3 id="迭代器说明">迭代器说明</h3><p>迭代器就是迭代的工具，迭代是一个重复的过程，并且每次重复都是基于上一次的结果而来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个迭代过程，虽然在重复，但是每次结果不一样</span></span><br><span class="line">dict1 = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>, <span class="string">&quot;y&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dict1:</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="built_in">len</span>(dict1):</span><br><span class="line">        print(dict1[i])</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这不是迭代过程，一直在重复，却没有变化</span></span><br><span class="line">    <span class="comment"># while True:</span></span><br><span class="line">    print(<span class="string">&quot;=-------&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>1=-------&gt;2=-------&gt;</code></pre><h2 id="可迭代对象">可迭代对象</h2><p>要想了解迭代器到底是什么？必须先要清楚一个概念，即什么是可迭代的对象？在python中，只要内置有<code>iter</code>方法的对象，都是可迭代的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这不是可迭代对象</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下都是可迭代的对象</span></span><br><span class="line">str1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">tup1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">dict1 = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">set1 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="迭代器用法">迭代器用法</h2><p>可迭代的对象执行iter方法得到的返回值就是迭代器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>, <span class="string">&quot;y&quot;</span>: <span class="number">2</span>, <span class="string">&quot;z&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">iter_dict1 = dict1.__iter__()</span><br><span class="line">print(iter_dict1)  <span class="comment"># 双下划线开头和结尾在python中称为魔法函数，之后在面向对象的章节中会详述，好奇的同学请自行百度</span></span><br><span class="line">print(iter_dict1.__next__())</span><br><span class="line">print(iter_dict1.__next__())</span><br><span class="line">print(iter_dict1.__next__())</span><br><span class="line"><span class="comment"># print(iter_dict1.__next__())  # 停止迭代</span></span><br><span class="line"></span><br><span class="line">set1 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">iter_set1 = set1.__iter__()</span><br><span class="line">print(iter_set1.__next__())</span><br><span class="line">print(iter_set1.__next__())</span><br><span class="line">print(iter_set1.__next__())</span><br><span class="line"><span class="comment"># print(iter_set1.__next__())  # 停止迭代</span></span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">iter_list1 = list1.__iter__()</span><br><span class="line">print(iter_list1.__next__())</span><br><span class="line">print(iter_list1.__next__())</span><br><span class="line">print(iter_list1.__next__())</span><br></pre></td></tr></table></figure><pre><code>&lt;dict_keyiterator object at 0x000001CA54634DB8&gt;xyzcba123</code></pre><h2 id="可迭代对象vs迭代器对象">可迭代对象VS迭代器对象</h2><h3 id="可迭代对象-1">可迭代对象</h3><p>可迭代对象无须获取，Python内置str，list，tuple，dict，set，file都是可迭代对象，它的特点是内置有iter方法，执行该方法会拿到一个返回值就是迭代器对象。</p><h3 id="迭代器对象">迭代器对象</h3><p>文件对象本身既是可迭代对象又是迭代器对象，可迭代对象执行iter方法，拿到的返回值就是迭代器对象。迭代器对象的特点是内置有next方法，执行该方法会拿到迭代器对象中的一个值，迭代器对象内置有iter方法，执行该方法会拿到迭代器本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;hello&quot;</span>  <span class="comment"># 可迭代对象</span></span><br><span class="line"></span><br><span class="line">iter_str1 = str1.__iter__()  <span class="comment"># 迭代器对象</span></span><br><span class="line">print(iter_str1.__next__())  <span class="comment"># 取出迭代器对象中的一个值</span></span><br><span class="line">print(iter_str1.__iter__() <span class="keyword">is</span> iter_str1)</span><br><span class="line">print(iter_str1.__iter__().__iter__() <span class="keyword">is</span> iter_str1)</span><br><span class="line">print(iter_str1.__iter__().__iter__().__iter__() <span class="keyword">is</span> iter_str1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件本身既是迭代器对象又是可迭代对象</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">print(f.__iter__() <span class="keyword">is</span> f)</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br></pre></td></tr></table></figure><h2 id="迭代器优缺点分析">迭代器优缺点分析</h2><h3 id="优点">优点</h3><h4 id="提供了一种可以不依赖索引取值的方式">提供了一种可以不依赖索引取值的方式</h4><p>假如你现在没有学过for循环，对于没有索引的可迭代对象如set，dict或者file这些应该怎么单独取出里面的每一个值？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集合</span></span><br><span class="line">set1 = &#123;</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line">iter_set1 = set1.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># try和except是第三阶段面向对象最后一个章节的内容，这里先简单使用一下</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:  <span class="comment"># 监测try下面的代码块是否出现异常</span></span><br><span class="line">        print(iter_set1.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:  <span class="comment"># 相当于if判断，如果出现的异常是StopIteration</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>, <span class="string">&quot;y&quot;</span>: <span class="number">2</span>, <span class="string">&quot;z&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">iter_dict1 = dict1.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(iter_dict1.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内容有五行，每行分别是一个数字1，2，3，4，5</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">iter_file1 = file1.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(iter_file1.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line"><span class="comment"># 有索引的可迭代对象自然也可以使用</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br><span class="line">iter_list1 = list1.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(iter_list1.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><pre><code>12345xyz1234455666</code></pre><h4 id="迭代器更加节省内存">迭代器更加节省内存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range用法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># item是一个可迭代对象，指的是从0到100000000000000000000000的所有数字</span></span><br><span class="line">item = <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">iter_item = item.__iter__()  <span class="comment"># 迭代器对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(iter_item.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="缺点">缺点</h3><h4 id="取值有缺陷">取值有缺陷</h4><p>取值麻烦，只能一个一个取，只能往后取，并且是一次性的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">iter_x = x.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(iter_x.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;第二次=================================&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># iter_x = x.__iter__()  # 注释这行第二次取不到，像小孩玩滑梯一样，要重新爬上去</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(iter_x.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="无法用len获取长度">无法用len获取长度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">iter_x = x.__iter__()</span><br><span class="line"><span class="comment"># print(len(iter_x))  # 没有获取长度方法</span></span><br></pre></td></tr></table></figure><h2 id="for循环的原理">for循环的原理</h2><p>for循环称之为迭代器循环，in后跟的必须是可迭代的对象，for循环会执行in后对象的iter方法，拿到迭代器对象，然后调用迭代器对象的next方法，拿到一个返回值赋值给一个变量，周而复始，直到取值完毕，for循环会检测到异常自动结束循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file1:  <span class="comment"># iter_file1=file1.__iter__()</span></span><br><span class="line">    print(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &#123;<span class="string">&quot;x&quot;</span>: <span class="number">1</span>, <span class="string">&quot;y&quot;</span>: <span class="number">2</span>&#125;:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><pre><code>xy</code></pre><h2 id="生成器说明">生成器说明</h2><p>我们可以把上面讲过的迭代器理解为一只老母鸡，理论上讲，老母鸡的肚子里可以有无穷个蛋，但是它需要一个一个的下蛋，Python给我们内置了几种老母鸡数据类型。</p><p>生成器其实本质就是迭代器，或者说生成器是特殊的迭代器，因为生成器是我们自己制造的迭代器。</p><h2 id="yield两个用法">yield两个用法</h2><ul><li>yield为我们提供了一种自定义迭代器的方式，可以在函数内用yield关键字，调用函数拿到的结果就是一个生成器。<br /></li><li>yield可以像return一样用于返回值，区别是return只能返回一次值，而yield可返回多次，因为yield可以保存函数执行的状态。<br /></li><li>yield与return用法比较</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yield</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_yield</span>():</span></span><br><span class="line">    print(<span class="string">&quot;=======&gt;first&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;=======&gt;second&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">&quot;=======&gt;third&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用yield返回，调用函数时，不会执行函数体代码，拿到的返回值就是一个生成器对象</span></span><br><span class="line">res = test_yield()</span><br><span class="line">print(res)  <span class="comment"># &lt;generator object test_yield at 0x1078f7660&gt;</span></span><br><span class="line">print(res.__iter__() <span class="keyword">is</span> res)</span><br><span class="line">print(res.__next__())</span><br><span class="line">print(res.__next__())</span><br><span class="line">print(res.__next__())</span><br><span class="line"></span><br><span class="line"><span class="comment"># return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_return</span>():</span></span><br><span class="line">    print(<span class="string">&quot;=======&gt;first&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 使用return返回，函数执行结束</span></span><br><span class="line">    print(<span class="string">&quot;=======&gt;second&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">&quot;=======&gt;third&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = test_return()</span><br></pre></td></tr></table></figure><pre><code>&lt;generator object test_yield at 0x000001F25CCC73C8&gt;True=======&gt;first1=======&gt;second2=======&gt;third3=======&gt;first</code></pre><h2 id="生成器的构造">生成器的构造</h2><p>函数内包含有yield关键字，再调用函数，就不会执行函数体代码，拿到的返回值就是一个生成器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chicken</span>():</span></span><br><span class="line">    print(<span class="string">&quot;=====&gt;first&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;=====&gt;second&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">&quot;=====&gt;third&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = chicken()</span><br><span class="line">print(obj)</span><br><span class="line">print(obj.__iter__() <span class="keyword">is</span> obj)</span><br><span class="line">print(obj.__next__())</span><br><span class="line">print(obj.__next__())</span><br><span class="line">print(obj.__next__())</span><br></pre></td></tr></table></figure><pre><code>&lt;generator object chicken at 0x000001F25CCC73C8&gt;True=====&gt;first1=====&gt;second2=====&gt;third3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_age</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> get_age(n - <span class="number">1</span>) + <span class="number">2</span>  <span class="comment"># age(4)+2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以写成以下三元表达式形式，貌似高端，但是会让程序看起来不够简洁</span></span><br><span class="line">    <span class="comment"># return 18 if n == 1 else age(n - 1) + 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(get_age(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><pre><code>26</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语雀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy学习</title>
      <link href="/6c51f6e8.html"/>
      <url>/6c51f6e8.html</url>
      
        <content type="html"><![CDATA[<h2 id="numpy库数组属性查看类型尺寸形状维度">numpy库数组属性查看：类型、尺寸、形状、维度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line">a1 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.complex128)  </span><br><span class="line">print(a1)  </span><br><span class="line">print(<span class="string">&quot;数据类型&quot;</span>,<span class="built_in">type</span>(a1))           <span class="comment">#打印数组数据类型  </span></span><br><span class="line">print(<span class="string">&quot;数组元素数据类型：&quot;</span>,a1.dtype) <span class="comment">#打印数组元素数据类型  </span></span><br><span class="line">print(<span class="string">&quot;数组元素总数：&quot;</span>,a1.size)      <span class="comment">#打印数组尺寸，即数组元素总数  </span></span><br><span class="line">print(<span class="string">&quot;数组形状：&quot;</span>,a1.shape)         <span class="comment">#打印数组形状  </span></span><br><span class="line">print(<span class="string">&quot;数组的维度数目&quot;</span>,a1.ndim)      <span class="comment">#打印数组的维度数目  </span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机械设计之链轮链条</title>
      <link href="/b57bb44b.html"/>
      <url>/b57bb44b.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用链轮型号大全">常用链轮型号大全</h1><p>常用链轮型号大全，常用链轮型号尺寸规格表，从04B到32B范围内的尺寸，参数有节距、滚子直径、齿号尺寸、排距和链条内宽等，以及链轮的一些计算方法。更多参数及计算方法请参照机械设计手册第三册链条的传动。</p><p>表内链号数乘以25.4/16mm为节距值。链条号的后缀A表示A系列，与滚子链国际标准ISO606-82的A系列等效，与滚子链美国标准ANSI B29.1-75相当;B系列则与ISO606-82的B系列等效，与英国滚子链标准BS228-84相当。在我国以A系列为主，供设计和出口用，B系列则主要供维修和出口用。</p><p><strong>下面是常用链轮的型号尺寸表：</strong></p><p>注：表中单排指单排链轮，多排指多排链轮。</p><table><thead><tr class="header"><th style="text-align: center;"><strong>链轮规格</strong></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">型号</td><td style="text-align: center;">节距</td><td style="text-align: center;">滚子直径</td><td style="text-align: center;">齿厚(单排）</td><td style="text-align: center;">齿厚（多排）</td><td style="text-align: center;">排距</td><td style="text-align: center;">链条内宽</td></tr><tr class="even"><td style="text-align: center;">04C</td><td style="text-align: center;">6.35</td><td style="text-align: center;">3.3</td><td style="text-align: center;">2.7</td><td style="text-align: center;">2.5</td><td style="text-align: center;">6.4</td><td style="text-align: center;">3.18</td></tr><tr class="odd"><td style="text-align: center;">04B</td><td style="text-align: center;">6</td><td style="text-align: center;">4</td><td style="text-align: center;">2.3</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">2.8</td></tr><tr class="even"><td style="text-align: center;">05B</td><td style="text-align: center;">8</td><td style="text-align: center;">5</td><td style="text-align: center;">2.6</td><td style="text-align: center;">2.4</td><td style="text-align: center;">5.64</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;">06C</td><td style="text-align: center;">9.525</td><td style="text-align: center;">5.08</td><td style="text-align: center;">4.2</td><td style="text-align: center;">4</td><td style="text-align: center;">10.13</td><td style="text-align: center;">4.77</td></tr><tr class="even"><td style="text-align: center;">06B</td><td style="text-align: center;">9.525</td><td style="text-align: center;">6.35</td><td style="text-align: center;">5.2</td><td style="text-align: center;">5</td><td style="text-align: center;">10.24</td><td style="text-align: center;">5.72</td></tr><tr class="odd"><td style="text-align: center;">08A</td><td style="text-align: center;">12.7</td><td style="text-align: center;">7.95</td><td style="text-align: center;">7.2</td><td style="text-align: center;">6.9</td><td style="text-align: center;">14.38</td><td style="text-align: center;">7.85</td></tr><tr class="even"><td style="text-align: center;">08B</td><td style="text-align: center;">12.7</td><td style="text-align: center;">8.51</td><td style="text-align: center;">7.1</td><td style="text-align: center;">6.8</td><td style="text-align: center;">13.92</td><td style="text-align: center;">7.75</td></tr><tr class="odd"><td style="text-align: center;">10A</td><td style="text-align: center;">15.875</td><td style="text-align: center;">10.16</td><td style="text-align: center;">8.7</td><td style="text-align: center;">8.4</td><td style="text-align: center;">18.11</td><td style="text-align: center;">9.4</td></tr><tr class="even"><td style="text-align: center;">10B</td><td style="text-align: center;">15.875</td><td style="text-align: center;">10.16</td><td style="text-align: center;">8.9</td><td style="text-align: center;">8.6</td><td style="text-align: center;">16.59</td><td style="text-align: center;">9.65</td></tr><tr class="odd"><td style="text-align: center;">12A</td><td style="text-align: center;">19.05</td><td style="text-align: center;">11.91</td><td style="text-align: center;">11.7</td><td style="text-align: center;">11.3</td><td style="text-align: center;">22.78</td><td style="text-align: center;">12.57</td></tr><tr class="even"><td style="text-align: center;">12B</td><td style="text-align: center;">19.05</td><td style="text-align: center;">12.07</td><td style="text-align: center;">10.8</td><td style="text-align: center;">10.5</td><td style="text-align: center;">19.46</td><td style="text-align: center;">11.68</td></tr><tr class="odd"><td style="text-align: center;">16A</td><td style="text-align: center;">25.4</td><td style="text-align: center;">15.88</td><td style="text-align: center;">14.6</td><td style="text-align: center;">14.1</td><td style="text-align: center;">29.29</td><td style="text-align: center;">15.75</td></tr><tr class="even"><td style="text-align: center;">16B</td><td style="text-align: center;">25.4</td><td style="text-align: center;">15.88</td><td style="text-align: center;">15.9</td><td style="text-align: center;">15.4</td><td style="text-align: center;">31.88</td><td style="text-align: center;">17.02</td></tr><tr class="odd"><td style="text-align: center;">20A</td><td style="text-align: center;">31.75</td><td style="text-align: center;">19.05</td><td style="text-align: center;">17.6</td><td style="text-align: center;">17</td><td style="text-align: center;">35.76</td><td style="text-align: center;">18.9</td></tr><tr class="even"><td style="text-align: center;">20B</td><td style="text-align: center;">31.75</td><td style="text-align: center;">19.05</td><td style="text-align: center;">18.3</td><td style="text-align: center;">17.7</td><td style="text-align: center;">36.45</td><td style="text-align: center;">19.56</td></tr><tr class="odd"><td style="text-align: center;">24A</td><td style="text-align: center;">38.1</td><td style="text-align: center;">22.23</td><td style="text-align: center;">23.5</td><td style="text-align: center;">22.7</td><td style="text-align: center;">45.44</td><td style="text-align: center;">25.22</td></tr><tr class="even"><td style="text-align: center;">24B</td><td style="text-align: center;">38.1</td><td style="text-align: center;">25.4</td><td style="text-align: center;">23.7</td><td style="text-align: center;">22.9</td><td style="text-align: center;">48.36</td><td style="text-align: center;">25.4</td></tr><tr class="odd"><td style="text-align: center;">28A</td><td style="text-align: center;">44.45</td><td style="text-align: center;">25.4</td><td style="text-align: center;">24.5</td><td style="text-align: center;">22.7</td><td style="text-align: center;">48.87</td><td style="text-align: center;">25.22</td></tr><tr class="even"><td style="text-align: center;">28B</td><td style="text-align: center;">44.45</td><td style="text-align: center;">27.94</td><td style="text-align: center;">30.3</td><td style="text-align: center;">28.5</td><td style="text-align: center;">59.56</td><td style="text-align: center;">30.99</td></tr><tr class="odd"><td style="text-align: center;">32A</td><td style="text-align: center;">50.8</td><td style="text-align: center;">28.58</td><td style="text-align: center;">29.4</td><td style="text-align: center;">28.4</td><td style="text-align: center;">58.55</td><td style="text-align: center;">31.55</td></tr><tr class="even"><td style="text-align: center;">32B</td><td style="text-align: center;">50.8</td><td style="text-align: center;">29.21</td><td style="text-align: center;">28.9</td><td style="text-align: center;">27.9</td><td style="text-align: center;">58.55</td><td style="text-align: center;">30.99</td></tr></tbody></table><p><strong>链条标记示例：</strong></p><p><code>链号为08A、单排链、87个链节长的滚子链可以这样标记：08A-1X87 GB1243.1-83。</code></p>]]></content>
      
      
      <categories>
          
          <category> 机械设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链轮 </tag>
            
            <tag> 链条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>edempy中使用到的函数总结</title>
      <link href="/6cfedda6.html"/>
      <url>/6cfedda6.html</url>
      
        <content type="html"><![CDATA[<p>前置设置<code>deck= Deck("Deckname")</code></p><h1 id="常用函数定义">常用函数定义</h1><h2 id="deck.timestepvalues"><code>deck.timestepValues</code></h2><table><thead><tr class="header"><th>数值类型</th><th>函数功能</th></tr></thead><tbody><tr class="odd"><td>列表</td><td>精确时间步长的浮点值列表，准确输出EDEM保存的时间，即每个时间步对应的工程时间。</td></tr></tbody></table><h2 id="deck.numtimesteps"><code>deck.numTimesteps</code></h2><table><thead><tr class="header"><th>数值类型</th><th>函数功能</th></tr></thead><tbody><tr class="odd"><td>整型</td><td>deck时间步的个数即工程文件下的.h5文件个数</td></tr></tbody></table><h2 id="deck.timestepj.geometry名称.getxforce"><code>deck.timestep[j].geometry['名称'].getXForce()</code></h2><table><thead><tr class="header"><th>数值类型</th><th>函数功能</th></tr></thead><tbody><tr class="odd"><td>浮点</td><td>指定时间步下指定物体在X方向的合力</td></tr></tbody></table><h2 id="deck.timestep1.timestep"><code>deck.timestep[1].timestep</code></h2><table><thead><tr class="header"><th>数值类型</th><th>函数功能</th></tr></thead><tbody><tr class="odd"><td>浮点</td><td>获取仿真时间步长</td></tr></tbody></table><p>这与<code>find_nearest()</code>功能相同，建议使用<code>find_nearest()</code></p><h2 id="deck.timestepi.particle0.getids"><code>deck.timestep[i].particle[0].getIds()</code></h2><table><thead><tr class="header"><th>数值类型</th><th>函数功能</th></tr></thead><tbody><tr class="odd"><td>整型列表</td><td>获取指定时间步下指定所有0号颗粒的ID</td></tr></tbody></table><p>##<code>deck.timestep[i].particle[0].getPositions()</code> | 数值类型 | 函数功能 | | ----------- | ----------- | |数组 | 获取指定时间步下指定所有0号颗粒的3D坐标位置|</p><h2 id="section"></h2><h1 id="函数模块">函数模块</h1><h2 id="寻找关键时间步长">寻找关键时间步长</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_nearest</span>(<span class="params">array, value</span>):</span></span><br><span class="line">array = np.array(array) <span class="comment"># 转换成数组</span></span><br><span class="line">timestep = (np.<span class="built_in">abs</span>(array - value)).argmin() <span class="comment">#</span></span><br><span class="line"><span class="keyword">return</span> timestep</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中:</p><p><code>np.abs</code> 计算数组各元素的绝对值 <code>np.argmin()</code> 沿给定轴返回最小元素的索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from edempy import Deck</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># Step 1: Setup figure</span><br><span class="line">fig, ax &#x3D; plt.subplots(1,1)</span><br><span class="line">ax.set(title&#x3D;&#39;Plough Force vs Time&#39;, xlabel&#x3D;&#39;Time [s]&#39;, ylabel&#x3D;&#39;X Force [N]&#39;, facecolor&#x3D;&#39;whitesmoke&#39;)</span><br><span class="line">ax.grid()</span><br><span class="line"></span><br><span class="line"># Step 2: Set up list of simulation decks to loop through(定义仿真查询工程文件的列表)</span><br><span class="line">decks &#x3D; [&#39;Plough_DryMaterial.dem&#39;, &#39;Plough_WetMaterial.dem&#39;]</span><br><span class="line">for i in range(0,len(decks)):</span><br><span class="line">deck &#x3D; Deck(decks[i])  # 读取h5文件</span><br><span class="line"></span><br><span class="line"># Step 3: Loop through timesteps calculating total X Force acting on Plough 每个时间步计算物体在X方向上受到的总力</span><br><span class="line">nTimesteps &#x3D; deck.numTimesteps  # 获取文件保存节点数量 0，1，2，3，4...</span><br><span class="line">xForce &#x3D; np.zeros([nTimesteps]) #</span><br><span class="line">for j in range(0,nTimesteps):</span><br><span class="line">xForce[j] &#x3D; -sum(deck.timestep[j].geometry[&#39;Plough&#39;].getXForce())</span><br><span class="line"></span><br><span class="line"># Step 4: Plot data</span><br><span class="line">t &#x3D; deck.timestepValues # 仿真节点对应的工程时间</span><br><span class="line">ax.plot(t,xForce)</span><br><span class="line">ax.legend(decks)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DEM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edemoy </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>edempy代码脚本</title>
      <link href="/22bb26bc.html"/>
      <url>/22bb26bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="静态堆积角测量">静态堆积角测量</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Created: 12/06/2019</span></span><br><span class="line"><span class="comment"># Author: Stefan Pantaleev</span></span><br><span class="line"><span class="comment"># Script for post-processing DEM simulaitons of a static angle of repose test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入依赖包</span></span><br><span class="line"><span class="keyword">from</span> edempy <span class="keyword">import</span> Deck</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取模拟数据</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(os.curdir):  <span class="comment"># 遍历文件夹、根目录、目录文件夹、目录里的文件</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&quot;.dem&quot;</span>):</span><br><span class="line">            name = file.replace(<span class="string">&quot;.dem&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;-------------------------------------------------------&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;Loading: &quot;</span> + <span class="built_in">str</span>(name) + <span class="string">&quot;.dem&quot;</span>)</span><br><span class="line">            print(<span class="string">&quot;-------------------------------------------------------&quot;</span>)</span><br><span class="line">            deck = Deck(os.path.join(root, file))  <span class="comment"># 把目录和文件名合成一个路径</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 读取首选项</span></span><br><span class="line">            <span class="comment"># 读取工程文件下设置的 Static_angle_of_repose_analyst_settings.txt参数</span></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(os.path.join(root, <span class="string">&#x27;Static_angle_of_repose_analyst_settings.txt&#x27;</span>)):</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(root, <span class="string">&#x27;Static_angle_of_repose_analyst_settings.txt&#x27;</span>),</span><br><span class="line">                          <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:  <span class="comment"># 读取preference内容</span></span><br><span class="line">                    preferences = file.readlines()</span><br><span class="line">                    sim_end = <span class="built_in">float</span>(preferences[<span class="number">3</span>])</span><br><span class="line">                    top_rad = <span class="built_in">float</span>(preferences[<span class="number">5</span>])</span><br><span class="line">                    base_rad = <span class="built_in">float</span>(preferences[<span class="number">7</span>])</span><br><span class="line">                    bin_size = <span class="built_in">float</span>(preferences[<span class="number">9</span>])</span><br><span class="line">                    angles = <span class="built_in">int</span>(preferences[<span class="number">11</span>])</span><br><span class="line">                    report = <span class="built_in">str</span>(preferences[<span class="number">13</span>])</span><br><span class="line">                    summary = <span class="built_in">str</span>(preferences[<span class="number">15</span>])</span><br><span class="line">                    plots = <span class="built_in">str</span>(preferences[<span class="number">17</span>])</span><br><span class="line">                    file.close()</span><br><span class="line">                    settings = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                settings = <span class="literal">False</span></span><br><span class="line">                sim_end = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查仿真是否运行结束</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sim_end - np.amax(deck.timestepValues) &lt; <span class="number">0.001</span> <span class="keyword">and</span> settings == <span class="literal">True</span>):</span><br><span class="line"></span><br><span class="line">                print(<span class="string">&quot;-------------------------------------------------------&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;Processing: &quot;</span> + <span class="built_in">str</span>(name) + <span class="string">&quot;.dem&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;-------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 寻找关键的时间步</span></span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">find_nearest</span>(<span class="params">array, value</span>):</span></span><br><span class="line">                    array = np.array(array)</span><br><span class="line">                    timestep = (np.<span class="built_in">abs</span>(array - value)).argmin() <span class="comment"># abs获取绝对值，argmin返回最小值。</span></span><br><span class="line">                    <span class="keyword">return</span> timestep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 分别找到填充完成的时间，仿真结束的时间步。</span></span><br><span class="line">                fill_end = find_nearest(deck.timestepValues, (sim_end))</span><br><span class="line">                sim_end = find_nearest(deck.timestepValues, (sim_end))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 将仿真区域划分Bin网格和角度，声明各自的一维数组</span></span><br><span class="line">                spacing = np.linspace(top_rad, base_rad, <span class="built_in">int</span>((base_rad - top_rad) / bin_size))</span><br><span class="line">                theta = np.linspace(<span class="number">0</span>, <span class="number">360</span>, angles) * math.pi / <span class="number">180</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 声明初始化数组</span></span><br><span class="line">                delta = np.zeros(<span class="built_in">len</span>(theta))  <span class="comment"># 堆积角</span></span><br><span class="line">                index_nonzero = np.zeros(<span class="built_in">len</span>(spacing))  <span class="comment"># 每个Bin初始0</span></span><br><span class="line">                SurfaceZ = np.zeros(shape=(<span class="built_in">len</span>(theta), <span class="built_in">len</span>(spacing)))  <span class="comment"># 初始化三维坐标</span></span><br><span class="line">                SurfaceY = np.zeros(shape=(<span class="built_in">len</span>(theta), <span class="built_in">len</span>(spacing)))</span><br><span class="line">                SurfaceX = np.zeros(shape=(<span class="built_in">len</span>(theta), <span class="built_in">len</span>(spacing)))</span><br><span class="line">                Coord = np.zeros((<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 创建一行三列数组</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获取颗粒中心</span></span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(deck.creatorData.h5PTypes)):  <span class="comment"># h5文件中显示的粒子型号列表，即颗粒个数</span></span><br><span class="line">                    Coord = np.append(Coord, deck.timestep[sim_end].particle[n].getPositions(), axis=<span class="number">0</span>)  <span class="comment"># 获取每个坐标</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (plots == <span class="string">&quot;Yes\n&quot;</span>):</span><br><span class="line">                    <span class="comment"># 绘制图表</span></span><br><span class="line">                    fig = plt.figure()</span><br><span class="line">                    ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">                    ax.scatter(Coord[:, <span class="number">0</span>], Coord[:, <span class="number">1</span>], Coord[:, <span class="number">2</span>], s=<span class="number">0.01</span>, c=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">                    ax.w_xaxis.set_pane_color((<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">                    ax.w_yaxis.set_pane_color((<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">                    ax.w_zaxis.set_pane_color((<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">                    ax.set_title(<span class="built_in">str</span>(name))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Bin中循环寻找位置最高的颗粒</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(theta)):</span><br><span class="line">                    <span class="comment"># 寻找BIN中心</span></span><br><span class="line">                    Grid_x = math.cos(theta[i]) * spacing</span><br><span class="line">                    Grid_y = math.sin(theta[i]) * spacing</span><br><span class="line">                    <span class="comment"># 查找表面颗粒</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(spacing)):</span><br><span class="line">                        distances = np.sqrt(np.square(Coord[:, <span class="number">0</span>] - Grid_x[j]) + np.square(Coord[:, <span class="number">1</span>] - Grid_y[j]))</span><br><span class="line">                        <span class="comment"># index_coord=np.where((Coord[:,0]&gt;(Grid_x[j]-bin_size/2)) &amp; (Coord[:,0]&lt;(Grid_x[j]+bin_size/2)) &amp; (Coord[:,1]&gt;(Grid_y[j]-bin_size/2)) &amp; (Coord[:,1]&lt;(Grid_y[j]+bin_size/2)))</span></span><br><span class="line">                        index_coord = np.where(distances &lt; bin_size / <span class="number">2</span>)</span><br><span class="line">                        surf = Coord[index_coord]</span><br><span class="line">                        <span class="comment"># 索引零值</span></span><br><span class="line">                        <span class="keyword">if</span> surf.shape[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                            Max = np.argmax(surf[:, <span class="number">2</span>])</span><br><span class="line">                            SurfaceX[i][j] = surf[Max, <span class="number">0</span>]</span><br><span class="line">                            SurfaceY[i][j] = surf[Max, <span class="number">1</span>]</span><br><span class="line">                            SurfaceZ[i][j] = surf[Max, <span class="number">2</span>]</span><br><span class="line">                            index_nonzero[j] = j</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            index_nonzero[j] = -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment"># 线性拟合到表面粒子</span></span><br><span class="line">                    fit = np.polyfit(spacing[index_nonzero != -<span class="number">1</span>], SurfaceZ[i][index_nonzero != -<span class="number">1</span>], <span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 休止角的计算与统计</span></span><br><span class="line">                    delta[i] = math.atan(<span class="built_in">abs</span>(fit[<span class="number">0</span>])) * <span class="number">180</span> / math.pi</span><br><span class="line">                    delta_mean = np.average(delta)</span><br><span class="line">                    delta_std = np.std(delta)</span><br><span class="line">                    delta_cov = delta_std / delta_mean * <span class="number">100</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 绘制线性拟合</span></span><br><span class="line">                    <span class="keyword">if</span> (plots == <span class="string">&quot;Yes\n&quot;</span>):</span><br><span class="line">                        ax.scatter(SurfaceX[i][:], SurfaceY[i][:], SurfaceZ[i][:], s=<span class="number">10</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">                        ax.plot(Grid_x, Grid_y, (spacing * fit[<span class="number">0</span>] + fit[<span class="number">1</span>]))</span><br><span class="line">                        ax.set_xlabel(<span class="string">&#x27;X coordinate&#x27;</span>)</span><br><span class="line">                        ax.set_ylabel(<span class="string">&#x27;Y coordinate&#x27;</span>)</span><br><span class="line">                        ax.set_zlabel(<span class="string">&#x27;Z coordinate&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 导出图像</span></span><br><span class="line">                <span class="keyword">if</span> (plots == <span class="string">&quot;Yes\n&quot;</span>):</span><br><span class="line">                    <span class="comment"># plt.show()</span></span><br><span class="line">                    fig.savefig(<span class="built_in">str</span>(name) + <span class="string">&#x27;_SAoR.png&#x27;</span>, dpi=<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 读取材料属性和接触参数</span></span><br><span class="line"></span><br><span class="line">                Material_Parameters = deck.creatorData.materials.getMaterials()</span><br><span class="line">                Interaction_Parameters = deck.creatorData.interactions.getInteractions()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 写出数据到文件</span></span><br><span class="line"></span><br><span class="line">                Names = [<span class="string">&quot;Angle of repose (deg)&quot;</span>, <span class="string">&quot;StDev (deg)&quot;</span>, <span class="string">&quot;CoV (%)&quot;</span>]</span><br><span class="line">                Values = [delta_mean, delta_std, delta_cov]</span><br><span class="line">                Units = [<span class="string">&quot;deg&quot;</span>, <span class="string">&quot;deg&quot;</span>, <span class="string">&quot;%&quot;</span>]</span><br><span class="line">                Empty_Column = [<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (report == <span class="string">&quot;Yes\n&quot;</span>):</span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="built_in">str</span>(name) + <span class="string">&quot;_Report&quot;</span> + <span class="string">&quot;.csv&quot;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvFile:</span><br><span class="line">                        writer = csv.writer(csvFile)</span><br><span class="line">                        writer.writerow([<span class="string">&quot;Operational parameters&quot;</span>])</span><br><span class="line">                        writer.writerow([<span class="string">&quot;Bin size (m)&quot;</span>, <span class="string">&quot;Number of measurements &quot;</span>])</span><br><span class="line">                        writer.writerows(np.column_stack([bin_size, angles]))</span><br><span class="line">                        writer.writerow([<span class="string">&quot;Material parameters&quot;</span>])</span><br><span class="line">                        writer.writerow(</span><br><span class="line">                            [<span class="string">&quot;Material&quot;</span>, <span class="string">&quot;Poisson ratio&quot;</span>, <span class="string">&quot;Shear modulus (Pa)&quot;</span>, <span class="string">&quot;Density (kg/m^3)&quot;</span>, <span class="string">&quot;Work function&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;Type&quot;</span>])</span><br><span class="line">                        writer.writerows(Material_Parameters)</span><br><span class="line">                        writer.writerow([<span class="string">&quot;Interaction parameters&quot;</span>])</span><br><span class="line">                        writer.writerow([<span class="string">&quot;Interaction&quot;</span>, <span class="string">&quot;Restitution&quot;</span>, <span class="string">&quot;Static friction&quot;</span>, <span class="string">&quot;Rolling friction&quot;</span>])</span><br><span class="line">                        <span class="keyword">for</span> line <span class="keyword">in</span> Interaction_Parameters:</span><br><span class="line">                            writer.writerow(line)</span><br><span class="line">                        writer.writerow([<span class="string">&quot;Results&quot;</span>])</span><br><span class="line">                        <span class="keyword">for</span> line <span class="keyword">in</span> np.column_stack([Names, Values, Units, Empty_Column]):</span><br><span class="line">                            writer.writerow(line)</span><br><span class="line">                        writer.writerow([<span class="string">&quot;Slice orientation (deg)&quot;</span>, <span class="string">&quot;Angle of repose (deg)&quot;</span>])</span><br><span class="line">                        <span class="keyword">for</span> line <span class="keyword">in</span> np.transpose([theta * <span class="number">180</span> / math.pi, delta]):</span><br><span class="line">                            writer.writerow(line)</span><br><span class="line">                    csvFile.close()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (summary == <span class="string">&quot;Yes\n&quot;</span>):</span><br><span class="line">                    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;Summary.csv&quot;</span>):</span><br><span class="line">                        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;Summary.csv&quot;</span>, <span class="string">&#x27;a&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvFile:</span><br><span class="line">                            writer = csv.writer(csvFile)</span><br><span class="line">                            writer.writerow(np.concatenate((<span class="built_in">str</span>(name), Values), axis=<span class="literal">None</span>))</span><br><span class="line">                            csvFile.close()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;Summary.csv&quot;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvFile:</span><br><span class="line">                            writer = csv.writer(csvFile)</span><br><span class="line">                            writer.writerow([<span class="string">&quot;Simulation&quot;</span>, <span class="string">&quot;Angle of repose (deg)&quot;</span>, <span class="string">&quot;StDev (deg)&quot;</span>, <span class="string">&quot;CoV (%)&quot;</span>])</span><br><span class="line">                            writer.writerow(np.concatenate((<span class="built_in">str</span>(name), Values), axis=<span class="literal">None</span>))</span><br><span class="line">                            csvFile.close()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (settings == <span class="literal">False</span>):</span><br><span class="line">                    print(<span class="string">&quot;----------------------------------------------------------------------&quot;</span>)</span><br><span class="line">                    print(<span class="built_in">str</span>(name) + <span class="string">&quot;.dem&quot;</span> + <span class="string">&quot; : Settings file not found. Moving to next simulation&quot;</span>)</span><br><span class="line">                    print(<span class="string">&quot;----------------------------------------------------------------------&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">&quot;--------------------------------------------------------------------&quot;</span>)</span><br><span class="line">                    print(<span class="built_in">str</span>(name) + <span class="string">&quot;.dem&quot;</span> + <span class="string">&quot; : Simulation unfinished. Moving to next simulation&quot;</span>)</span><br><span class="line">                    print(<span class="string">&quot;--------------------------------------------------------------------&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;-------------------------------------------------------&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;No more simulations in the folder-analysis is complete!&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;-------------------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> EDEM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> edempy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三水平和混合水平析因设计与分式析因设计</title>
      <link href="/b30f0de6.html"/>
      <url>/b30f0de6.html</url>
      
        <content type="html"><![CDATA[<p>3<sup>k</sup>析因设计</p><p>现在讨论3<sup>k</sup>析因设计，也就是，有 k 个因子、每个因子有 3 个水平的析因设计.因子和交互作用将用大写字母表示我们把因子的 3 个水平看作低、中、低这些因子水平可用种不同</p><p>3<sup>k</sup>设计的确是关心响应函数弯曲性的实验者的-一个可能选择.不过，有两点必须考虑：</p><blockquote><ol type="1"><li>3<sup>k</sup>设计不是模拟二次关系最有效的方法.第11章讨论的响应曲面设计是更好的方法. (2)如第6章所讨论的，添加中心点的2<sup>k</sup>设计是得到弯曲性特征的极好方法.它容许人们把设计的大小和复杂性保持在低的程度上，并同时得出- 一些针对弯曲性的保护措施.<strong>因此，如果弯曲性很重要，就可以如图6.37所示，在二水平设计的基础上增加若干轴点上的试验（axial run）来获得<code>中心复合设计</code></strong>.这种实验的序贯方法比带有定量因子的3k设计的效率高得多.</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实验设计与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3^k^析因设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidworks图号名称分离</title>
      <link href="/e494319e.html"/>
      <url>/e494319e.html</url>
      
        <content type="html"><![CDATA[<h1 id="零件体图号-名称分离">零件体图号-名称分离</h1><blockquote><p>适用命名规则 <code>代号-代号-代号-名称</code> 分离后：代号=代号-代号-代号。名称=名称</p></blockquote><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> swApp <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line"><span class="keyword">Dim</span> Part <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line"><span class="keyword">Dim</span> SelMgr <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line"><span class="keyword">Dim</span> boolstatus <span class="keyword">As</span> <span class="type">Boolean</span></span><br><span class="line"><span class="keyword">Dim</span> longstatus <span class="keyword">As</span> <span class="type">Long</span>, longwarnings <span class="keyword">As</span> <span class="type">Long</span></span><br><span class="line"><span class="keyword">Dim</span> Feature <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line"><span class="keyword">Dim</span> a <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"><span class="keyword">Dim</span> b <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Dim</span> m <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Dim</span> e <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Dim</span> k <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Dim</span> t <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Dim</span> c <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Dim</span> j <span class="keyword">As</span> <span class="type">Integer</span></span><br><span class="line"><span class="keyword">Dim</span> strmat <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Dim</span> tempvalue <span class="keyword">As</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">Sub</span> main()</span><br><span class="line"><span class="comment">&#x27;link solidworks</span></span><br><span class="line"><span class="keyword">Set</span> swApp = Application.SldWorks</span><br><span class="line"><span class="keyword">Set</span> Part = swApp.ActiveDoc</span><br><span class="line"><span class="keyword">Set</span> SelMgr = Part.SelectionManager</span><br><span class="line">swApp.ActiveDoc.ActiveView.FrameState = <span class="number">1</span></span><br><span class="line"><span class="comment">&#x27;设定变量</span></span><br><span class="line">c = swApp.ActiveDoc.GetTitle() <span class="comment">&#x27;零件名</span></span><br><span class="line">strmat = Chr(<span class="number">34</span>) + Trim(<span class="string">&quot;SW-Material&quot;</span> + <span class="string">&quot;@&quot;</span>) + c + Chr(<span class="number">34</span>)</span><br><span class="line">blnretval = Part.DeleteCustomInfo2(<span class="string">&quot;&quot;</span>, <span class="string">&quot;图样代号&quot;</span>)</span><br><span class="line">blnretval = Part.DeleteCustomInfo2(<span class="string">&quot;&quot;</span>, <span class="string">&quot;图样名称&quot;</span>)</span><br><span class="line"><span class="comment">&#x27;blnretval = Part.DeleteCustomInfo2(&quot;&quot;, &quot;材料&quot;)</span></span><br><span class="line">a = InStrRev(c, <span class="string">&quot;-&quot;</span>) - <span class="number">1</span> <span class="comment">&#x27;重点：分隔标识符，这里是一个空格,也可用其他符号区分</span></span><br><span class="line"><span class="keyword">If</span> a &gt; <span class="number">0</span> <span class="keyword">Then</span></span><br><span class="line">k = Left(c, a)</span><br><span class="line">t = Left(LTrim(e), <span class="number">3</span>)</span><br><span class="line"><span class="keyword">If</span> t = <span class="string">&quot;GBT&quot;</span> <span class="keyword">Then</span></span><br><span class="line">e = <span class="string">&quot;GB/T&quot;</span> + <span class="keyword">Mid</span>(k, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">e = k</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line">b = <span class="keyword">Mid</span>(c, a + <span class="number">2</span>)</span><br><span class="line">t = Right(c, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">If</span> t = <span class="string">&quot;.SLDPRT&quot;</span> <span class="built_in">Or</span> t = <span class="string">&quot;.SLDASM&quot;</span> <span class="built_in">Or</span> t = <span class="string">&quot;.sldprt&quot;</span> <span class="built_in">Or</span> t = <span class="string">&quot;.sldasm&quot;</span> <span class="keyword">Then</span></span><br><span class="line">j = Len(b) - <span class="number">7</span> <span class="comment">&#x27;消除后缀（区分大小写，即含4种）</span></span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">j = Len(b)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line">m = Left(b, j)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line">blnretval = Part.DeleteCustomInfo2(<span class="string">&quot;&quot;</span>, <span class="string">&quot;代号&quot;</span>)</span><br><span class="line">blnretval = Part.DeleteCustomInfo2(<span class="string">&quot;&quot;</span>, <span class="string">&quot;名称&quot;</span>)</span><br><span class="line">blnretval = Part.AddCustomInfo3(<span class="string">&quot;&quot;</span>, <span class="string">&quot;代号&quot;</span>, swCustomInfoText, e) <span class="comment">&#x27;代号</span></span><br><span class="line">blnretval = Part.AddCustomInfo3(<span class="string">&quot;&quot;</span>, <span class="string">&quot;名称&quot;</span>, swCustomInfoText, m) <span class="comment">&#x27;名称</span></span><br><span class="line"><span class="keyword">Set</span> swApp = Application.SldWorks</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Solidworks </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetbrains系列无限重置试用插件</title>
      <link href="/f6150bc7.html"/>
      <url>/f6150bc7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>IntelliJ IDEA AppCode CLion DataGrip GoLand PhpStorm PyCharm Rider RubyMine WebStorm</p></blockquote><h2 id="安装">安装</h2><h3 id="插件市场安装">📜 插件市场安装：</h3><p>在Settings/Preferences... -&gt; Plugins 内手动添加第三方插件仓库地址：https://plugins.zhile.io 搜索：IDE Eval Reset插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？ 插件会提示安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aria2+rclone+GD</title>
      <link href="/a6fa799b.html"/>
      <url>/a6fa799b.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装-aria2">安装 Aria2</h1><p>这里使用 <a href="https://github.com/P3TERX/aria2.sh">Aria2 一键安装管理脚本 增强版</a>，执行下面的代码下载并运行脚本，出现脚本操作菜单输入 1 开始安装。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N git.io&#x2F;aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; .&#x2F;aria2.sh</span><br></pre></td></tr></table></figure> # 安装和配置 Rclone RCLONE 官方提供了一键安装脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;rclone.org&#x2F;install.sh | sudo bash</span><br></pre></td></tr></table></figure><p>安装完后，输入 <code>rclone config</code> 命令进入交互式配置选项，按照提示一步一步来进行操作即可。</p><h1 id="配置自动上传脚本">配置自动上传脚本</h1><p>Aria2 一键安装管理脚本 增强版 整合了 Aria2 完美配置 ，安装后会附带一些附加功能脚本功能脚本，RCLONE 自动上传脚本就是其中之一。由于默认不启用，所以需要手动启用。</p><blockquote><p>TIPS: 本项目的上传脚本使用更稳定快速的原生命令上传方式，而非处在测试阶段的挂载方式，这点和一般的脚本不同。 输入<code>nano /root/.aria2c/aria2.conf</code>打开 Aria2 配置文件进行修改。或使用Aria2 一键安装管理脚本 增强版中的手动修改选项打开配置文件进行修改。找到“下载完成后执行的命令”，把<code>clean.sh</code>替换为<code>upload.sh</code>。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 文件保存设置 ##</span><br><span class="line"></span><br><span class="line"># 下载目录。可使用绝对路径或相对路径, 默认: 当前启动位置</span><br><span class="line">dir&#x3D;&#x2F;root&#x2F;googledrive</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 下载完成后执行的命令</span><br><span class="line"></span><br><span class="line">&#96;on-download-complete&#x3D;&#x2F;root&#x2F;.aria2c&#x2F;upload.sh&#96;</span><br></pre></td></tr></table></figure> nano 编辑器的操作方法参见《Linux 下适合新手的文本编辑器 nano 使用教程》 输入<code>nano /root/.aria2c/script.conf</code>打开附加功能脚本配置文件进行修改，有中文注释，按照自己的实际情况进行修改，第一次使用只建议修改网盘名称。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 网盘名称(RCLONE 配置时填写的 name)</span><br><span class="line">drive-name&#x3D;Gdrive</span><br><span class="line"></span><br><span class="line"># 网盘目录(上传目标目录，网盘中的文件夹路径)。注释或留空为网盘根目录，末尾不要有斜杠。</span><br><span class="line">drive-dir&#x3D;&#x2F;vps</span><br><span class="line"></span><br><span class="line"># 移动目标目录</span><br><span class="line">dest-dir&#x3D;&#x2F;root&#x2F;googledrive</span><br></pre></td></tr></table></figure><p>重启 Aria2 。脚本选项重启或者执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service aria2 restart</span><br></pre></td></tr></table></figure><h1 id="安装ariang">安装AriaNg</h1><h2 id="方法1-宝塔面板安装">方法1 宝塔面板安装</h2><p>Centos安装脚本 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure> 新建站点-导入AriaNg</p><h2 id="方法2-apache安装">方法2 Apache安装</h2><p>安装 AriaNg 前，我们需要先准备一款 Web 服务器。在本文中，我采用的是 Apache，一行命令就能搞定：<code>sudo yum install httpd</code> 。完成后，执行 <code>sudo systemctl start httpd.service</code> 就能启动 Apache。 这时，用浏览器访问你的 VPS IP 应该会看到下图所示的欢迎页面，表示 Apache 已成功启用。如果无法连接的话，可能是由于 CentOS 自带的 httpd 服务占用了 80 端口，可以通过修改监听端口来解决。 接着，让我们下载 AriaNg，你可以在其 GitHub Releases 页面找到其正式版的下载链接。撰写本文时，AriaNg 的最新版为 1.1.0，因此，要执行的命令是 <code>wget https://github.com/mayswind/AriaNg/releases/download/1.1.0/AriaNg-1.1.0.zip</code>。</p><p>随后，执行命令<code>unzip AriaNg-1.1.0.zip -d /var/www/html/AriaNg</code>，解压下载的 AriaNg 文件并将其移动至 Apache 的工作目录下。如果提示未找到 <code>unzip</code> 的话，请先执行 <code>yum install -y unzip zip</code>。 现在，让我们用浏览器访问 你的VPS.IP/AriaNg，如果出现下图所示网页，就说明配置成功。在 AriaNg 设置中，填写你的 VPS 或域名地址、端口、密钥等，就可以用图形界面愉快地享受下载了。</p><h1 id="问题记录">问题记录</h1><h2 id="问题一找不到-jq-命令">问题一、找不到 jq 命令</h2><p>我在安装后测试下载无法上传网盘，通过命令查看日志：</p><p>tail -f /root/.aria2c/aria2.log 在下载结束后报了如下错误： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8&#x2F;19 07:26:59 [^[[1;32mNOTICE^[[0m] Download complete: &#x2F;root&#x2F;downloads&#x2F;aria2.conf</span><br><span class="line">&#x2F;root&#x2F;.aria2c&#x2F;core: line 109: jq: command not found</span><br><span class="line">&#x2F;root&#x2F;.aria2c&#x2F;core: line 111: jq: command not found</span><br><span class="line">08&#x2F;19 07:26:59 [^[[31mERROR^[[0m] Failed to get download directory!</span><br></pre></td></tr></table></figure> 发现是由于 jq 命令找不到到导致的，Centos 下通过如下命令安装 jq <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装EPEL源：</span><br><span class="line">yum install epel-release</span><br><span class="line"># 安装完EPEL源后，可以查看下jq包是否存在：</span><br><span class="line">yum list jq</span><br><span class="line"># 安装jq：</span><br><span class="line">yum install jq</span><br></pre></td></tr></table></figure> 重试问题解决。</p><h1 id="方法二一键脚本配置">方法二：一键脚本配置</h1><h2 id="vps购买">vps购买</h2><h2 id="脚本命令">脚本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">curl https:&#x2F;&#x2F;rclone.org&#x2F;install.sh | sudo bash</span><br><span class="line">mkdir -p &#x2F;root&#x2F;.config&#x2F;rclone</span><br><span class="line">mkdir &#x2F;root&#x2F;gdrive</span><br><span class="line">wget -N git.io&#x2F;aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; .&#x2F;aria2.sh</span><br><span class="line"># 设置rpc密码</span><br><span class="line"># 更改配置</span><br><span class="line">wget https:&#x2F;&#x2F;akiyama.bassmio.workers.dev&#x2F;0:&#x2F;Gd&#x2F;aria2.conf -O &#x2F;root&#x2F;.aria2c&#x2F;aria2.conf</span><br><span class="line">wget https:&#x2F;&#x2F;akiyama.bassmio.workers.dev&#x2F;0:&#x2F;Gd&#x2F;script.conf -O &#x2F;root&#x2F;.aria2c&#x2F;script.conf</span><br><span class="line">wget https:&#x2F;&#x2F;akiyama.bassmio.workers.dev&#x2F;0:&#x2F;Gd&#x2F;rclone.conf -O &#x2F;root&#x2F;.config&#x2F;rclone&#x2F;rclone.conf</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">#重启</span><br><span class="line">service aria2 restart</span><br></pre></td></tr></table></figure><h1 id="linux-vps-基本命令">Linux VPS 基本命令</h1><p>我们Linux VPS用命令才能管理他，我们来罗列一些基本和简单的Linux的命令</p><ol type="1"><li><p><code>ls</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls &#x2F; 查看根目录</span><br><span class="line">ls -a &#x2F; 查看根目录下所要文件，包括隐藏文件</span><br><span class="line">ls -l &#x2F; 详细列出目录下文件的权限、所有者文件大小等详细信息，可以简单输入||</span><br><span class="line">ls -f &#x2F; 列出目录下文件名及其目录类型；文件后有*表示可执行文件、@表示符号链接、&#x2F;结尾表示目录名</span><br><span class="line">ls –t依照最后修改文件时间列出文件名</span><br><span class="line">ls –R列出当前目录和其子目录的文件名</span><br><span class="line">ls –color&#x3D;never不以颜色方式显示</span><br><span class="line">ls –color&#x3D;always均以颜色方式显示</span><br><span class="line">ls –color&#x3D;auto系统自动判断</span><br></pre></td></tr></table></figure></p></li><li><p><code>cd</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">切换用户当前目录</span><br><span class="line">cd &#x2F;etc 使用绝对路径进入”&#x2F;etc”目录</span><br><span class="line">cd ..&#x2F;dev 使用相对路径进入”&#x2F;dev”目录</span><br><span class="line">cd ~ 返回用户宿主目录</span><br><span class="line">cd . 用户的当前目录</span><br><span class="line">cd .. 返回上一级目录</span><br></pre></td></tr></table></figure></p></li><li><p><code>pwd</code> 查看用户当前所在位置</p></li><li><p><code>mkdir</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建目录</span><br><span class="line">mkdir dir1 创建单个目录</span><br><span class="line">mkdir dir1 dir2 dir3 创建多个目录</span><br></pre></td></tr></table></figure></p></li><li><p><code>rmdir</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删除目录，删除的目录必须是空的</span><br><span class="line">rmdir dir1 删除目录dir1</span><br><span class="line">rmdir dir1 dir2 删除目录dir1、dir2</span><br></pre></td></tr></table></figure></p></li><li><p><code>touch</code> 创建文件命令 如果文件不存在的话直接创建空文件，如果存在只是更改一下时间属性</p></li><li><p><code>file</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看文件类型</span><br><span class="line">File命令能够识别linux系统中大多数文件类型，可识别文本文件。二进制可执行文件、压缩文件等</span><br></pre></td></tr></table></figure></p></li><li><p><code>cp</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制文件</span><br><span class="line">cp 源文件 目标位置</span><br><span class="line">cp dir1&#x2F;test&#x2F;test &#x2F;home</span><br></pre></td></tr></table></figure></p></li><li><p><code>rm</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除文件</span><br><span class="line">rm是删除文件的命令，linux中的文件删除是不可恢复的</span><br><span class="line">rm –r 循环删除直到删除没有(可用于删除目录)</span><br><span class="line">rm –f 强制删除</span><br><span class="line">rm –rf 强制删除目录和文件</span><br></pre></td></tr></table></figure></p></li><li><p><code>mv</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">移动文件或者重命名</span><br><span class="line">mv &#x2F;etc&#x2F;test &#x2F;etc&#x2F;test2</span><br></pre></td></tr></table></figure></p></li><li><p><code>vi</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打开或新建文件，并将光标置于第一行首</span><br><span class="line">:w 保存当前文件</span><br><span class="line">:e filename 打开文件filename进行编辑</span><br><span class="line">:x 保存当前文件并退出</span><br><span class="line">:q 退出vi</span><br><span class="line">:q! 不保存文件并退出vi</span><br></pre></td></tr></table></figure></p></li><li><p><code>查看文件内容</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">more 3.txt</span><br><span class="line">cat 3.txt</span><br><span class="line">tac 3.txt</span><br><span class="line">head -3 3.txt</span><br><span class="line">tail -3 3.txt</span><br></pre></td></tr></table></figure></p></li><li><p><code>find</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;ect -name *local</span><br></pre></td></tr></table></figure></p></li><li><p><code>whereis</code> 查找命令的环境变量 whereis ls whereis find</p></li><li><p><code>ln</code> 建立链接文件 hard link symbol link 相关于桌面快捷方式 ln 3.txt 4 ln -s 3.txt 5</p></li><li><p><code>users and groups</code> useradd passwd userdel groupadd groupdel</p></li><li><p><code>wc</code> 统计指定文本文件的行数、字数、字符数</p></li><li><p><code>grep</code> 在指定的文本文件中查找指定的字符串</p></li><li><p>解压缩 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar，用tar命令可以压缩文件夹，同样也可以解压缩。</span><br><span class="line">tar -czvf name.tar &#x2F;etc&#x2F;name 压缩一个文件夹</span><br><span class="line">tar -zxvf name.tar 解压缩文件</span><br><span class="line">zip方法需要安装zip和unzip工具，命令：yum install zip unzip</span><br><span class="line">zip -r name.zip &#x2F;etc&#x2F;name 压缩</span><br><span class="line">unzip name.zip 解压缩</span><br></pre></td></tr></table></figure></p></li><li><p><code>wget</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;storyday.com&#x2F;index.php (将会http下载这个网页，并且保存成index.php)</span><br><span class="line">wget -O wordpress.tar.gz http:&#x2F;&#x2F;wordpress.org&#x2F;latest.tar.gz 将下载的结果保存wordpress.tar.gz</span><br><span class="line">wget -r ftp:&#x2F;&#x2F;10.8.8.8&#x2F;movie&#x2F; 目录结构和网站标题都给记录下来</span><br><span class="line">wget -r -nd ftp:&#x2F;&#x2F;10.8.8.8&#x2F;movie&#x2F; 没有目录结构</span><br><span class="line">wget -r -nH ftp:&#x2F;&#x2F;10.8.8.8&#x2F;movie&#x2F; 有movie目录</span><br></pre></td></tr></table></figure></p></li><li><p>其他命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">date —- 显示和设置日期时间</span><br><span class="line">uptime —- 显示现在时间、系统运行时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载</span><br><span class="line">stat —- 显示指定文件的相关信息</span><br><span class="line">who、w —- 显示在线登录用户</span><br><span class="line">whoami —- 显示用户自己的身份</span><br><span class="line">id —- 显示当前用户的id信息</span><br><span class="line">hostname —- 显示主机名称</span><br><span class="line">uname —- 显示操作系统信息</span><br><span class="line">dmesg —- 显示系统启动信息</span><br><span class="line">du —- 显示指定的文件（目录）已使用的磁盘空间的总量</span><br><span class="line">df —- 显示文件系统磁盘空间的使用情况</span><br><span class="line">free —- 显示当前内存和交换空间的使用情况</span><br><span class="line">fdisk -l —- 显示磁盘信息</span><br><span class="line">locale —- 显示当前语言环境</span><br></pre></td></tr></table></figure></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> VPS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aria2 </tag>
            
            <tag> rclone </tag>
            
            <tag> googledrive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How To Ask Questions The Smart Way</title>
      <link href="/cb2f1325.html"/>
      <url>/cb2f1325.html</url>
      
        <content type="html"><![CDATA[<h1 id="提问的智慧">提问的智慧</h1><blockquote><p><strong>How To Ask Questions The Smart Way</strong></p></blockquote><blockquote><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p></blockquote><blockquote><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p></blockquote><blockquote><p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr/faqs/smart-questions.html</a></p></blockquote><blockquote><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p></blockquote><h2 id="声明">声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介">简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，"好问题！"是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前">在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol type="1"><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 <a href="http://groups.google.com/">Google 论坛</a>和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时">当你提问时</h2><h3 id="慎选提问的论坛">慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次"扫射"所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="stack-overflow">Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-irc-论坛">网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 "用<strong>我们的</strong>版本"。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步使用项目邮件列表">第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有"使用者" 也有"开发者"（或"黑客"）邮件列表或论坛，而你又不会动到那些源代码，那么就向"使用者"列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在"使用者" 列表或论坛中几天都没有回复，可以试试前往"开发者"列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题">使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复">使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰正确精准且语法正确的语句">用清晰、正确、精准且语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it's</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/小白">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/火星文">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me; I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms, but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I've posted my question in $LANGUAGE and English. I'll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题">使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物">精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精">话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。 第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加； 第二，简化问题使你更有可能得到<strong>有用</strong>的答案； 第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-bug">别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#在提问之前">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课">低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测">描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong> &gt; 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， &gt; 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， &gt; 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 &gt; 所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状">按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程">描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong> &gt; 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p><p><strong>聪明问题</strong> &gt; 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， &gt; 但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复">别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求">清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时">询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#话不在多而在精">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来">别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句">去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急">即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪而且有时还很有帮助">礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后加个简短的补充说明">问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案">如何解读答案</h2><p><a id="RTFM"></a> ### RTFM 和 STFW：如何知道你已完全搞砸了</p><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href="http://lmgtfy.com/">Google 是你的朋友</a></strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂">如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应">处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者">如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题">不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr /><p><a id="q1"></a> &gt; 问题：我能在哪找到 X 程序或 X 资源？</p><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com">Google</a> 吗？</p><p><a id="q2"></a> &gt; 问题：我怎样用 X 做 Y？</p><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a> &gt;问题：如何设定我的 shell 提示？？</p><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a> &gt; 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a> &gt; 问题：我的{程序/设定/SQL 语句}不工作</p><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><p><a id="q6"></a> &gt; 问题：我的 Windows 电脑有问题，你能帮我吗？</p><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a> &gt; 问题：我的程序不会动了，我认为系统工具 X 有问题</p><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a> &gt; 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a> &gt; 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题">好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 "Foonly Flurbamatic 2600"，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答">如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题">如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源">相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p><h2 id="鸣谢">鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ipv6+vps实现校园免流量</title>
      <link href="/934bd877.html"/>
      <url>/934bd877.html</url>
      
        <content type="html"><![CDATA[<p>自建ss服务器教程 2020年8月16日增加多用户一键脚本, 支持流量限制等，更新五合一的TCP网络加速脚本。</p><p>自建ss/ssr教程很简单，整个教程分三步：</p><p>第一步：购买VPS服务器</p><p>第二步：一键部署VPS服务器</p><p>第三步：一键加速VPS服务器 （五合一的TCP网络加速脚本）</p><a id="more"></a><h1 id="第一步购买vps服务器">第一步：购买VPS服务器</h1><p>VPS服务器需要选择国外的，首选国际知名的vultr，速度不错、稳定且性价比高，按小时计费，能够随时开通和删除服务器，新服务器即是新ip。</p><p>vultr（vps最低2.5美元/月，vultr全球17个服务器位置可选，包括日本、韩国、新加坡、洛杉矶、德国、荷兰等。支持支付宝和paypal付款。）</p><pre><code>2.5美元/月的服务器配置信息：单核 512M内存 10G SSD硬盘 带宽1G 500G流量/月 (不推荐，仅提供ipv6 ip，不推荐)3.5美元/月的服务器配置信息：单核 512M内存 10G SSD硬盘 带宽1G 500G流量/月 (推荐)5美元/月的服务器配置信息： 单核 1G内存 25G SSD硬盘 带宽1G 1000G流量/月 (推荐)10美元/月的服务器配置信息： 单核 2G内存 55G SSD硬盘 带宽1G 2000G流量/月20美元/月的服务器配置信息： 2cpu 4G内存 80G SSD硬盘 带宽1G 3000G流量/月40美元/月的服务器配置信息： 4cpu 8G内存 160G SSD硬盘 带宽1G 4000G流量/月</code></pre><p>vultr实际上是折算成小时来计费的，比如服务器是5美元1个月，那么每小时收费为5/30/24=0.0069美元 会自动从账号中扣费，只要保证账号有钱即可。如果你部署的服务器实测后速度不理想，你可以把它删掉（destroy），重新换个地区的服务器来部署，方便且实用。因为新的服务器就是新的ip，所以当ip被墙时这个方法很有用。当ip被墙时，为了保证新开的服务器ip和原先的ip不一样，先开新服务器，开好后再删除旧服务器即可。在账号的Billing选项里可以看到账户余额。</p><div class="note warning flat"><p>点击图中的CentOS几个字，会弹出选项，然后选中centos6或7！ （不要选默认的centos8，脚本不支持centos8！）</p></div><h1 id="第二步部署vps服务器">第二步：部署VPS服务器</h1><p>部署教程：</p><p>下载windows xshell软件并安装后，打开软件</p><p>连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。</p><p>CentOS 6和7/Debian6+/Ubuntu14+ ShadowsocksR/Shadowsocks一键部署管理脚本：</p><h2 id="脚本一ssr">脚本一(SSR)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ToyoDAdoubi&#x2F;doubi&#x2F;master&#x2F;ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="脚本二ss">脚本二（SS）</h2><p>脚本二没有单独做图文教程，参考脚本一的图文说明摸索下就会了。安装完成后，快捷管理命令： <code>bash ss-go.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ToyoDAdoubiBackup&#x2F;doubi&#x2F;master&#x2F;ss-go.sh &amp;&amp; chmod +x ss-go.sh &amp;&amp; bash ss-go.sh</span><br></pre></td></tr></table></figure><h2 id="脚本三ssr多用户管理脚本">脚本三（SSR多用户管理脚本）</h2><p>脚本三没有单独做图文教程，参考脚本一的图文说明摸索下就会了。安装完成后，快捷管理命令：bash ssrmu.sh 所有用户流量清零命令: <code>bash ssrmu.sh clearall</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ToyoDAdoubiBackup&#x2F;doubi&#x2F;master&#x2F;ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh</span><br></pre></td></tr></table></figure><p>如果提示 <code>wget: command not found</code> 的错误，这是你的系统精简的太干净了，wget都没有安装，所以需要安装wget。CentOS系统安装wget命令: <code>yum install -y wget</code> Debian/Ubuntu系统安装wget命令: <code>apt-get install -y wget</code></p><hr /><ol type="1"><li><p>复制上面的脚本一代码到VPS服务器里，复制代码用鼠标右键的复制（整个代码一起复制，而不是分段哦！），然后在vps里面右键粘贴进去，因为ctrl+c和ctrl+v无效。接着按回车键，脚本会自动安装，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：<code>bash ssr.sh</code></p></li><li><p>输入数字1来安装SSR服务端。如果输入1后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令bash ssr.sh 再尝试。</p></li><li><p>依次输入自己想设置的端口和密码 (密码建议用复杂点的字母组合，端口号为40-65535之间的数字)，回车键用于确认</p></li></ol><blockquote><p>注：关于端口的设置，总的网络总端口有6万多个，理论上可以任意设置，但不要以0开头！但是有的地区需要设置特殊的端口才有效，一些特殊的端口比如80、143、443、1433、3306、3389、8080。</p></blockquote><ol start="4" type="1"><li><p>选择想设置的加密方式，比如10，按回车键确认</p></li><li><p>接下来是选择协议插件,选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端（SS客户端没有协议和混淆的选项），可以根据需求进行选择，演示选择y</p></li><li><p>之后进行混淆插件的设置。</p></li></ol><blockquote><p>注意：如果协议是origin，那么混淆也必须是plain；如果协议不是origin，那么混淆可以是任意的。有的地区需要把混淆设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）或者（origin和plain一起使用），让其看起来像随机数据更好。（特别注意：tls 1.2_ticket_auth容易受到干扰！请选择除tls开头以外的其它混淆！！！）</p></blockquote><p>进行混淆插件的设置后，会依次提示你对设备数、单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。</p><blockquote><p>注意：关于限制设备数，这个协议必须是非原版且不兼容原版才有效，也就是必须使用SSR协议的情况下，才有效！</p></blockquote><ol start="7" type="1"><li>之后代码就正式自动部署了，提示你下载文件，输入：y</li></ol><p>耐心等待一会，出现下面的界面即部署完成：</p><p>根据图就可以看到自己设置的SSR账号信息，包括IP、端口、密码、加密方式、协议插件、混淆插件，这些信息需要填入你的SSR客户端。提醒一下：二维码链接地址由于域名失效不可用，所以部署好的账号需要自己在客户端里面手动填写信息。</p><p>如果之后想修改账号信息，直接输入快捷管理命令： <code>bash ssr.sh</code> 进入管理界面，选择相应的数字来进行一键修改。例如：</p><p>脚本演示结束。</p><p>此脚本是开机自动启动，部署一次即可。最后可以重启服务器确保部署生效（一般情况不重启也可以）。重启需要在命令栏里输入reboot ，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2～5分钟，重启过程中Xshell会自动断开连接，等VPS重启好后才可以用Xshell软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用xshell软件断开，然后重新连接你的ip，再复制代码进行部署。</p><blockquote><p>注意：如果创建的是centos7的服务器，需要使用命令关闭防火墙，否则无法使用代理。CentOS 7.0默认使用的是firewall作为防火墙。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看防火墙状态命令：firewall-cmd --state</span><br><span class="line">停止firewall命令：systemctl stop firewalld.service</span><br><span class="line">禁止firewall开机启动命令：systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><h1 id="第三步一键加速vps服务器">第三步：一键加速VPS服务器</h1><p>五合一的TCP网络加速脚本，包括了BBR原版、BBR魔改版、暴力BBR魔改版、BBR plus（首选）、Lotsever(锐速)安装脚本。可用于KVMXen架构，不兼容OpenVZ（OVZ）。支持Centos 6+ / Debian 7+ / Ubuntu 14+，BBR魔改版不支持Debian 8。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;chiakge&#x2F;Linux-NetSpeed&#x2F;master&#x2F;tcp.sh&quot;</span><br><span class="line"></span><br><span class="line">chmod +x tcp.sh</span><br><span class="line"></span><br><span class="line">.&#x2F;tcp.sh</span><br></pre></td></tr></table></figure><p>如果提示 <code>wget: command not found</code> 的错误，这是你的系统精简的太干净了，wget都没有安装，所以需要安装wget。CentOS系统安装wget命令: <code>yum install -y wget</code> Debian/Ubuntu系统安装wget命令: <code>apt-get install -y wget</code></p><p>安装完成后，脚本管理命令为： <code>./tcp.sh</code></p><p>操作方法：先安装内核，重启vps让内核生效，再启动对应的加速即可。数字1的BBR/BBR魔改内核对应数字4、5、6的BBR加速、BBR魔改加速和暴力BBR魔改版加速。数字2的BBRplus内核对应数字7的BBRplus加速。数字3的锐速加速内核对应数字8的锐速加速。</p><p>以安装暴力BBR魔改版加速为例，我们先安装对应的内核，输入数字1</p><p>内核安装完成后，输入y进行重启，重启才能让内核生效</p><p>重启完成后，输入数字6来启动暴力BBR魔改版加速</p><p>输入 <code>./tcp.sh</code> 查看最终是否启动成功。</p><p>如果想换一个加速，输入数字9进行卸载加速，然后进行同样的操作，安装内核再安装对应内核的加速即可。</p><p>注意：如果在安装内核环节出现这样一张图，注意选择NO</p><h1 id="下载插件switchyomega">下载插件：switchyomega</h1><p>安装插件，打开chrome，打开扩展程序，将下载的插件拖动到扩展程序页面，添加到扩展。</p><p>启动SSR客户端后，右键SSR客户端图标，选择第一个“系统代理模式”，里面有3个子选项，选择"全局模式“，之后就可以用浏览器设置好了的代理模式（http） <code>127.0.0.1</code> 和 <code>1080</code> 翻墙，此模式下所有的网站都会走SSR代理。</p><div class="note success flat"><p>参考：<a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B">自建ss服务器教程</a></p></div><h1 id="vps相关指令">VPS相关指令</h1><h2 id="启动ssr服务器命令集">启动SSR服务器命令集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure><h2 id="查看bbr加速">查看BBR加速</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;tcp.sh</span><br></pre></td></tr></table></figure><h2 id="防火墙常用代码">防火墙常用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># systemctl status firewalld &#x2F;&#x2F;查看防火墙状态</span><br><span class="line"># systemctl start firewalld &#x2F;&#x2F;开启防火墙</span><br><span class="line"># firewall-cmd --zone&#x3D;public --add-port&#x3D;22&#x2F;tcp --permanent &#x2F;&#x2F;打开22端口</span><br><span class="line"># firewall-cmd --reload &#x2F;&#x2F;重载防火墙</span><br><span class="line"># reboot &#x2F;&#x2F; **重启服务**</span><br></pre></td></tr></table></figure><ul><li>Firewalld 防火墙的常见命令:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start firewalld &#x2F;&#x2F;启动</span><br><span class="line"></span><br><span class="line"># systemctl status firewalld &#x2F;&#x2F;查看状态</span><br><span class="line"></span><br><span class="line"># systemctl disable firewalld &#x2F;&#x2F;停止</span><br><span class="line"></span><br><span class="line"># systemctl stop firewalld &#x2F;&#x2F;禁用</span><br><span class="line"></span><br><span class="line"># firewall-cmd --zone&#x3D;public --list-ports &#x2F;&#x2F;查看所有打开的端口</span><br><span class="line"></span><br><span class="line"># firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp —permanent &#x2F;&#x2F;打开端口</span><br><span class="line"></span><br><span class="line"># firewall-cmd --zone&#x3D;public --query-port&#x3D;80&#x2F;tcp &#x2F;&#x2F; 查看端口状态</span><br><span class="line"></span><br><span class="line"># firewall-cmd --zone&#x3D;public --remove-port&#x3D;80&#x2F;tcp —permanent &#x2F;&#x2F;关闭端口</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VPS </category>
          
          <category> SSR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> Ipv6 </tag>
            
            <tag> SSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.2文献</title>
      <link href="/c9c15c43.html"/>
      <url>/c9c15c43.html</url>
      
        <content type="html"><![CDATA[<h1 id="中文文献">中文文献</h1><h2 id="基于离散元与多体动力学的微耕机旋耕刀轴负荷分析1">基于离散元与多体动力学的微耕机旋耕刀轴负荷分析<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><h3 id="dem-mdb耦合算法与计算过程">DEM-MDB耦合算法与计算过程</h3><blockquote><p>DEM-MDB耦合算法</p></blockquote><p>DEM-MDB耦合算法通过DEM模块和MDB模块分别计算颗粒系统动力学和机械系统动力学程序通过接触检测判断每一-个时步下颗粒与边界是否接触，进而根据叠合量计算颗粒和边界的作用力，该作用力被传递给DEM模块和MDB模块，程序通过时步迭代完成余下所有计算。具体的计算步骤如下：</p><p>（1）MBD模块计算当前时步各构件的运动学参数（位置、速度、加速度）和 动力学参数（铰约束反力和驱动力）。 （2）DEM模块从MBD模块中获取各构件的位置数据。 （3）DEM模块计算颗粒与各构件之间的相互作用。 （4）DEM模块开始当前时步的颗粒迭代计算。 （5）DEM模块将步骤（4）中颗粒对构件的作用力和力矩传递给MBD模块，MBD模块更新构件的运动学参数（位置、速度、加速度）和动力学参数（铰约束反力和驱动力）。</p><p><span class="math inline">\(t_{i+1}=t_{i}+h\)</span>，<span class="math inline">\(h\)</span>为时间步长，程序进入下一时步，不断迭代，直到达到计算所设置时间。计算流程如下图 ：</p><figure><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/14/zU5bLvcIq27H8nB.png" alt="耦合算法计算流程图" /><figcaption aria-hidden="true">耦合算法计算流程图</figcaption></figure><h2 id="基于离散元的稻板田旋耕功耗预测模型研究2">基于离散元的稻板田旋耕功耗预测模型研究<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><h3 id="技术路线plackett-burman等步长爬坡试验"><code>技术路线</code>：Plackett-Burman+等步长爬坡试验</h3><p>利用离散元软件建立旋耕作业模型，进行<strong>等步长爬坡试验</strong>， 通过步阶次序建立接触参数与功耗指标之间的函数关系，代入标定参照试验功耗值，最终确定稻板田旋耕功耗预 测模型的接触参数取值，完成模型的构建。验证<strong>模型的适用性</strong>，不同工况和不同刀具。 建立功耗预测模型目的：各参数对功耗的影响不明确。 确定接触参数的取值范围（GEEM材料库） 通过试验设计与数学方法令仿真值逼近测试值，最终确定接触参数是离散元参数标定的主要途径。采用<u>最陡爬坡</u>标定方法</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/41959523">Plackett Burman</a></p></blockquote><ul><li>Plackett-Burman试验提取显著因素（步阶接触参数-驱动功耗）</li><li>以参照试验结果为目标值，将各显著因素以等步长增加的方式创建各步阶参数水平并开展仿真试验，建立驱动功耗和步阶次序的关系。</li><li>实际实验相同工况和结构参数下的驱动功耗。</li><li>综合获得接触参数组的步阶次序。</li><li>预测模型适用性验证<ul><li>不同刀辊不同工况、方差验证</li><li>原尺度刀辊试验</li></ul></li></ul><h2 id="基于离散元的双轴旋耕机功耗预测模型3">基于离散元的双轴旋耕机功耗预测模型<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></h2><blockquote><p>关键词：分层土壤、结构参数、功耗、Box-Behnken、方差分析</p></blockquote><p><strong>不具体研究接触参数的准确性</strong></p><p>研究配置参数（空间位置以及回转半径）对功耗的影响，响应面分析、建立驱动功耗模型。</p><ul><li>介绍研究背景、选题原因、现有的研究存在的问题和本文的主要目的。</li><li>确定影响研究对象的关键参数。</li><li><strong>分别标定三层不同含水率土壤的接触参数和接触模型参数</strong>。</li><li>对机构模型进行简化。</li><li>Box-Behnken方法进行试验设计。</li><li>使用Design-Expert软件对双轴旋耕机功耗的仿真试验结果进行<strong>多元回归拟合</strong>。对功耗试验结果进行<strong>方差分析</strong>，利用Design-Expert软件的响应优化器，对<strong>建立的二次回归方程进行优化求解</strong>。目标函数为用来验证所得功耗拟合方程的有效性。</li></ul><p><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/19/fUyxtIzeo73uvwX.png" alt="image-20210119181204889" /> <img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/19/Y4al6icPgEjUBvA.png" alt="image-20210119181325710" /></p><h2 id="麻山药种植田沙壤土流动性离散元模型颗粒放尺效应4">麻山药种植田沙壤土流动性离散元模型颗粒放尺效应<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></h2><p>以沙壤土为研究对象,在EDEM离散元软件中构建非球形颗粒,进行双目标参数标定试验,采用放大颗粒粒径方法,利用转鼓、坍塌与FT4流变仿真试验,从颗粒群动态堆积角、流动质量、流动速率以及能量等方面探究了颗粒放尺效应对颗粒群物理特性的影响。</p><p><strong><code>放尺因子2</code> 时，装置阻力和功耗为原尺度的两倍。仿真过程中沙壤土的流动效应与原尺基本一致。</strong></p><h2 id="深松土壤扰动行为的离散元仿真与试验5">深松土壤扰动行为的离散元仿真与试验<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></h2><p><strong>EDEM后处理</strong></p><p>仿真分析：</p><ul><li><p>土壤扰动状态分析</p><ul><li>土壤扰动机理分析：利用离散元方法，从土壤的<strong>纵向</strong>、<strong>横向剖面</strong>对不同深度土层土壤的扰动状态进行分析，并采用高速摄影试验对浅层土壤的扰动过程与仿真结果进行了对比。</li><li>不同位置土壤扰动状态分析：不同深度、不同位置土壤的扰动情况。根据深松铲对纵向、横向土壤的扰动情况，选择<strong>纵向剖视间隔为 50 mm、横向剖视间隔为 100 mm</strong>，不同位置、不同深度土壤的扰动状态。</li></ul></li><li><p>土壤运动状态分析</p><ul><li><p>深松铲位置对土壤整体运动状态的影响：<strong>不同时刻</strong>土壤运动速度大小及方向的分布状态进行了对比。</p></li><li><p>不同位置土壤运动速度：为进一步说明不同深度土层土壤在不同方向上的运动速度随深松过程的变化情况，获取了浅层、中层、深层 3 层土壤的水平(x 方向)、垂直(y 方向)、侧向(z 方向) 的平均运动速度与瞬时最大运动速度。</p></li></ul></li><li><p>土壤扰动效果分析</p><ul><li>地表土壤纵向堆积角 反映深松后地表土壤的扰动状态。</li></ul></li></ul><p><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/19/og3JdqXbMNslZeK.png" alt="image-20210119214648808"  /></p><p><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/22/gNYy54qz98EPK2C.png" alt="image-20210119214703801"  /></p><p><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/22/6i5JIT7qdfktR2l.png" alt="image-20210119214718394"  /></p><p><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/22/frdITHaM1L9bcRp.png" alt="image-20210119214819348"  /></p><h2 id="基于振动的土壤挖掘阻力与耗能特性试验研究6"><a href="zotero://select/library/items/7CDEPK2Q">基于振动的土壤挖掘阻力与耗能特性试验研究</a><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></h2><figure><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/22/GEfBUhplsFxdWC2.png" alt="image-20210122234116273" /><figcaption aria-hidden="true">image-20210122234116273</figcaption></figure><p><strong>重点学习对数据图表的分析</strong></p><p>在有限试验次数下，分别研究各因素对，降租率和耗能比的影响。</p><figure><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/22/ivXxnVyfpPJN6zb.png" alt="image-20210122234700245" /><figcaption aria-hidden="true">image-20210122234700245</figcaption></figure><h2 id="半自动压缩基质型西瓜钵苗移栽机成穴器参数优化7"><a href="zotero://select/library/items/YH3AWIB9"><strong>半自动压缩基质型西瓜钵苗移栽机成穴器参数优化</strong></a><a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></h2><blockquote><p>关键词：成穴器、小端直径、成穴深度，参数优化、穴底平整度</p></blockquote><p><em>引言摘抄：</em></p><p>圆饼状压缩基质（以草本泥炭、木质素为主要原料，压制成圆饼状，单个质量（40±3）g）常用于培育种子较大、根系较为发达的西瓜和甜瓜类经济作物。其幼苗质量相对于基质块很小，且幼苗较为矮小，多采用覆膜种植，开沟式移裁机能够进行小株距裸苗移栽，但不能实现覆膜移栽。<strong>鸭嘴式移栽机能够移栽基质块较小的钵苗，鸭嘴式移裁机对幼苗苗龄和外观形状要求高，受其工作方式的限制 ，圆饼状压缩基质培育的幼苗落入鸭嘴时，不能保证钵苗的直立，且栽植时鸭嘴在土壤中打开，<u>部分土壤回流造成穴底不平整，难以保证压缩基质型钵苗移栽直立</u>。</strong>成穴式移裁机也存在对土壤土质及含水率要求较高等问题，但是该类机型对栽植幼苗要求较低，采用先成穴后放苗工作方式，能够保证钵苗的直立，可实现快速移栽作业，因此发展成穴式移栽技术具有较好的科研前景，作为成穴式移裁机械的关键工序成穴技术的研究还未取得突破性的进展。 文章根据移栽圆饼压缩基质培育的西瓜钵苗的农艺要求，结合<strong>旱地移栽机械</strong>作业的特点，以半自动压缩基质型西瓜钵苗移栽机中成穴装置的成穴器为研究对象，利用离散元法对成穴器成穴过程进行研究，<strong>探究小端直径不同的成穴器在不同理论成穴深度的成穴效果，结合田间试验对成穴器参数进行优化。</strong></p><p><strong>文章脉络</strong> 引言→结构和工作原理→参数化设计(成穴机理、穴的参数化方程)→EDEM仿真试验</p><figure><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/02/04/4zOU1rALpkFCgvI.png" alt="image-20210204215939028" /><figcaption aria-hidden="true">image-20210204215939028</figcaption></figure><p>鸭嘴栽植过程中阻力随栽植深度不同的变化函数值（函数包含栽植深度<span class="math inline">\(h\)</span>、固定鸭嘴角度<span class="math inline">\(\alpha\)</span>、活动鸭嘴角度<span class="math inline">\(\beta\)</span>）</p><h2 id="深松铲错位布置对土壤扰动影响的仿真与试验研究"><a href="zotero://select/library/items/AVC42DBU">深松铲错位布置对土壤扰动影响的仿真与试验研究</a></h2><p>土壤是由各种矿质粒子、有机物、水等物质组成，其基本组成单元为大小各异的土粒经水分聚合、生物作用、分子间作用力等作用下聚合分解而成，因此借助离散元方法对土壤进行仿真模拟具有独特的仿真优势。现实中受空间格局和检测分析手段的限制，只能宏观粗略分析土壤的静态运动结果、误差大，局限性较多。将离散元技术应用到农业耕作领域，可以从微观粒子层面观察机具与土壤相互作用的过程，了解在土壤被切割、翻垡和开沟等过程中土壤颗粒破裂、流动状态，分析土壤的扰动量、作业速度等，从而为分析耕作时土壤复杂的运动行为分析提供了新思路、新方法，促进耕作机具的改进与研发。</p><h2 id="油菜钵苗移栽机成穴作业方式及参数优化"><a href="zotero://select/library/items/XTPCS5VA">油菜钵苗移栽机成穴作业方式及参数优化</a></h2><blockquote><p>摘要：针对油菜移栽机成穴器对土壤扰动大、孔穴穴壁土壤孔隙度低影响钵苗生长质量的问题，该研究根据油菜钵苗 移栽农艺要求，选取成穴器成穴方式（取土式、挤压式）、成穴器下端尺寸、成穴器<code>入土深度</code>为试验因素，利用离散元法 对成穴过程进行仿真分析，以<code>穴内截面回土系数</code>和穴壁土壤孔隙度为指标评价各试验因素对孔穴形态及<code>土壤扰动效果</code>的 影响。仿真结果表明，取土式成穴是相对较优的成穴方式，所成孔穴的横截面形状为矩形，形成符合农艺要求孔穴的较 优参数组合为：成穴器下端尺寸 50 mm，入土深度 40 mm，所成孔穴上端尺寸的长和宽分别为 69 和 79 mm，有效深度为 40 mm，穴壁土壤孔隙率为 48.5%，穴内截面回土系数为 0.08。结合土槽试验对成穴器作业性能进行验证，结果表明，孔穴 上端纵长、上端宽度、有效深度、穴壁土壤孔隙度和穴内截面回土系数的试验结果与仿真结果之间的<code>误差平均值</code>分别为 4.8%、 3.4%、1.2%、1.5%和 14.2%，优化后的成穴器能够成型满足设计要求的孔穴，该研究结果可为成穴器的优化提供参考。</p></blockquote><hr /><h1 id="section">Ⅱ</h1><h2 id="基于dem的不同几何形状深松机耕作力及扰动特性研究"><a href="zotero://select/library/items/B7KIDT5R">基于DEM的不同几何形状深松机耕作力及扰动特性研究</a></h2><p><strong>MT试验验证DEM模型参数的准确性。</strong></p><blockquote><p>通过调节各参数实现深度-阻力曲线近似相等。</p></blockquote><p><img src= "img/ballloading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/BassMio/PicGO/2021/3/%E5%9F%BA%E4%BA%8EDEM%E7%9A%84%E4%B8%8D%E5%90%8C%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6%E6%B7%B1%E6%9D%BE%E6%9C%BA%E8%80%95%E4%BD%9C%E5%8A%9B%E5%8F%8A%E6%89%B0%E5%8A%A8%E7%89%B9%E6%80%A7%E7%A0%94%E7%A9%B6.webp" /></p><p><strong>试验不准确得到解释</strong>： 尽管所有土壤扰动参数的实验值均低于模拟值，但其趋势是一致的。 此外，实验值与模拟值之间的误差小于10％。 因此，考虑到现场的复杂情况，仿真结果是可以接受的。</p><h2 id="耕作过程中土壤位移的离散元模拟方法"><a href="https://www.zotero.org/users/7301587/items/B8ITYVIB">耕作过程中土壤位移的离散元模拟方法</a></h2><blockquote><p>Modelling approach for soil displacement in tillage using discrete element method</p></blockquote><figure><img src= "img/ballloading.gif" data-lazy-src="F:%5Conedrive%5CNote%5Cpicture%5Cimage-20210404101208456.png" alt="image-20210404101208456" /><figcaption aria-hidden="true">image-20210404101208456</figcaption></figure><p>图11。试验测得的土壤位移剖面。未填充的圆表示示踪剂的初始位置。实心圆表示示踪物的扰动位置。Symbol=−Z 0，50，100表示为其构建特定剖面的示踪剂网格线的垂直位置（负值表示土壤表面以下的位置）。蓝色代表粗砂；红色代表壤土；绿色代表沙壤土。X轴表示纵向；Y轴表示横向；Z轴表示垂直方向，其中0表示soi的日面。</p><p>Based on the soil disturbance results, all DEM models with different particle radii had low relative errors (&lt;12%) for soil rupture distance ratio, except for 3 mm radii. The simulated soil disturbance areas were in close agreement with those measured using particle radii smaller than 11 mm, as indicated by the low relative errors (1.70e6.44%). Fragmentation index is able to describe soil failure imposed by the implement in HMB model with proper particle sizes (7e11 mm radii).</p><hr /><h1 id="参考文献">参考文献</h1><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="zotero://select/library/items/ITJC4WIS">基于离散元与多体动力学的微耕机旋耕刀轴负荷分析</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="zotero://select/library/items/22VAUMU3">基于离散元的稻板田旋耕功耗预测模型研究</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="zotero://select/library/items/F3R6ET6W">基于离散元的双轴旋耕机功耗预测模型</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p><a href="zotero://select/library/items/NEUCEDAA">麻山药种植田沙壤土流动性离散元模型颗粒放尺效应</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5" role="doc-endnote"><p><a href="zotero://select/library/items/B7NBI2W6">深松土壤扰动行为的离散元仿真与试验</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6" role="doc-endnote"><p><a href="zotero://select/library/items/7CDEPK2Q">基于振动的土壤挖掘阻力与耗能特性试验研究</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7" role="doc-endnote"><p><a href="zotero://select/library/items/YH3AWIB9">半自动压缩基质型西瓜钵苗移栽机成穴器参数优化</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> DEM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DEM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程图绘图标准</title>
      <link href="/84d6aa19.html"/>
      <url>/84d6aa19.html</url>
      
        <content type="html"><![CDATA[<details green><summary> 识读装配图 </summary>              <div class='content'>              <div id="识读装配图" class="tabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#识读装配图-1">读装配图</button></li><li class="tab"><button type="button" data-href="#识读装配图-2">画装配图</button></li></ul><div class="tab-contents"><div id="识读装配图-1" class="tab-item-content active"><div class="timeline"><p class="p h2">读装配图的步骤和方法</p><div class="timenode"><div class="meta"><p><p>概括了解</p></p></div><div class="body"><ol type="1"><li>从标题栏和查阅的有关资料中，了解机器或部件的名称和大致用途</li><li>从明细表和图上的零件序号中，了解各零件的名称、数量、材料和它们所在的位置</li><li>分析表达方法。根据图样上的视图、剖视图等的配置和标注，找出投射方向、剖切位置、各视图间的投影关系，分析全图采用了哪些表达方法，为什么采用它们？明确各视图所表达的重点</li></ol></div></div><div class="timenode"><div class="meta"><p><p>了解工作原理和装配关系</p></p></div><div class="body"><p>在概括了解的基础上，分析各零件间的定位、润滑、密封、连接方式和配合要求，从而搞清运动与非运动零件的相对运动关系。一般由动力输入件（如手轮、把手、带轮、齿轮和主动轴等）开始，沿着各传动系统按次序了解每个零件的作用，零件间的连接关系</p></div></div><div class="timenode"><div class="meta"><p><p>分析零件的结构形状及作用</p></p></div><div class="body"><p>通过前面的分析，能够了解大部分零件的形状和作用，而对少数复杂的零件还需应进一步分析。首先利用投影关系、剖面线方向和间隔、零件序号以及装配图中的规定画法和特殊画法等将零件分离出来，然后想象其形状，了解其作用</p></div></div><div class="timenode"><div class="meta"><p><p>尺寸分析</p></p></div><div class="body"><p>分析装配图中所注各类尺寸，从而进一步了解各零件间的配合性质和装配关系</p></div></div><div class="timenode"><div class="meta"><p><p>总结归纳</p></p></div><div class="body"><p>为了对装配图有一全面认识，还应根据机器或部件的工作原理从部件的装拆顺序、安装方法和技术要求进行综合分析，从而对整台机器或部件的设计意图和装配工艺性等有较完整的认识</p></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div id="识读装配图-2" class="tab-item-content"><div class="timeline"><p class="p h2">由装配图拆画零件图的步骤和方法</p><div class="timenode"><div class="meta"><p><p>仔细阅读装配图</p></p></div><div class="body"><p>在拆画零件图之前，一定要认真阅读装配图，完成读图的各项要求。再根据装配图的装配关系，利用投影关系和剖面线的方向和间隔、零件序号等来分离零件并分析所拆零件的作用及结构形状</p></div></div><div class="timenode"><div class="meta"><p><p>构思零件形状，拆出零件并补画所缺图线</p></p></div><div class="body"><p>从装配图上分离出零件的投影线后，要补画出所缺的图线。一般包括： - 该零件在装配图上被其他零件遮住的轮廓 - 在装配图上没有表达清楚的零件结构，要根据零件作用和装配关系重新设计 - 在装配图上被省略的工艺结构，如倒角、圆角、退刀槽、中心孔等，都应在零件图中表达清楚，使零件的结构形状表达得更为完整</p></div></div><div class="timenode"><div class="meta"><p><p>确定表达方案</p></p></div><div class="body"><p>零件图和装配图所表达的重点不同，因此拆图时原装配图中对该零件的表达方案仅供参考，不能盲目地照抄装配图，而应根据零件本身的结构形状和“零件的视图选择”中的要求重新考虑。例如，轴套类零件应按加工位置安放；箱体类零件、叉架类零件应按工作位置安放来选取主视图的投影方向等</p></div></div><div class="timenode"><div class="meta"><p><p>合理标注零件尺寸</p></p></div><div class="body"><p>拆画零件图时，尺寸标注应从以下几方面考虑： 1. 除某些外形尺寸和装配时需要调整的尺寸外，装配图中注出的尺寸可以直接移到相关零件图上。凡注有配合代号的尺寸，应根据配合类别、公差等级注出上下偏差或公差带代号 2. 对有标准规定的尺寸，如倒角、螺纹孔、螺栓孔、沉孔、螺纹退刀槽、砂轮越程槽、键槽等，应从有关标准和手册中查取 3. 有些尺寸需要根据装配图上所给的参数进行计算，如齿轮分度圆直径，应根据模数和齿数计算而定 4. 其他在装配图中未标出的尺寸可按装配图的比例，直接从图形上量取，对于一些非重要尺寸应取整数 5. 在注写零件图上的尺寸时，对有装配关系的尺寸要注意相互协调，不能互相矛盾。另外，第6章中的零件图尺寸标注原理仍然适用，尺寸标注仍应综合考虑设计和工艺要求，力求注得完整、清晰和合理</p></div></div><div class="timenode"><div class="meta"><p><p>合理注写零件技术要求</p></p></div><div class="body"><p>在零件图中应注写表面粗糙度代号、公差配合代号或极限偏差，必要时还要加注形位公差、热处理和表面处理等技术要求。这些内容可根据零件在装配体的作用、装配关系以及装配图上提出的要求，并参阅有关资料予以确定</p></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 机械设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用DEM术语定义</title>
      <link href="/aa8f7094.html"/>
      <url>/aa8f7094.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用dem术语定义1">常用DEM术语定义<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h1><h2 id="接触数据">接触数据</h2><p>接触被认为是在<strong>数据采集点时刻</strong>颗粒体之间发生的冲击。换言之，在数据采集点某一个接触可能正在发生。接触与过程中的力和接触位置等信息有关。这些信息都是一些离散的值。如果某两个颗粒在一段时间里完成接触，比如在4个数据采集点的时间里完成了一个接触行为，则EDEM会存储4个接触信息。这4个接触信息具有不同的接触力信息和接触位置信息等。</p><h2 id="碰撞数据">碰撞数据</h2><p><strong>碰撞是完整的冲击</strong>。意思是当两个颗粒单元碰撞时，相关作用情况将存储为一个作用信息，不论两个颗粒体在接触点持续了多长时间。有关碰撞持续时间的数据将被存储。这些相关数据包括总能量消耗，最小/最大/平均法向力数据等。碰撞可能发生在两个采集点之间，而且它们不会被记录成接触信息。</p><p>EDEM将接触信息作为标准记录信息。如果要记录碰撞信息，则要选择存储碰撞数据选项。注意选取了存储碰撞数据选项会极大地消耗内存。碰撞数据一直存储在内存里，直到EDEM按照设定的读取速率写出这些数据后，它们的存储空间才被释放。如果大量的碰撞信息被存储起来，而输出这些信息的频率太低，那么存储在内存里的碰撞数据会非常大并且所有的内存资源将全部被占用。为了避免这种情况，应该保持较高的数据写出频率。</p><h2 id="时间步长">时间步长</h2><p>颗粒离散元方法假设在一个计算时步内，颗粒受到的力不变，即加速度不变。显然如果时步选得过大，必然造成颗粒接触过程描述不精确，数值计算会发散，对于硬球模型来说还会使得部分颗粒的碰撞被漏检；如果时步选得过小，又会造成计算量急剧增大，因此选取合适的计算时步非常重要。目前有三种确定时间步长的方法，对应不同的物理机制。</p><h3 id="瑞利波rayleigh-wave法">瑞利波（Rayleigh wave）法</h3><p><code>EDEM软件时间步</code>用DEM进行仿真的关键问题之一就是确定Rayleigh时间步长。上的最大值，每个颗粒的配位数（每个颗粒总的涉及的接触数）保持大于1。它是由下式<span class="math inline">\(\eqref{eq5-1}\)</span>决定： <span class="math display">\[\label{eq5-1}T_{R}=\pi R\left(\frac{\rho}{G}\right)^{\frac{1}{2}}(0.1631 \sigma+0.8766)^{-1} \]</span> 其中，<span class="math inline">\(R\)</span>是颗粒半径；<span class="math inline">\(\rho\)</span>是颗粒密度；<span class="math inline">\(G\)</span>是剪切模量；<span class="math inline">\(\sigma\)</span>是泊松比。</p><p>实际使用过程中，通常只取该值的一个百分比作为操作时间步长。并且对高配位数颗粒集合的仿真（一般是配位颗粒数≥4的情况），时间步长选取为0.2<span class="math inline">\(T_{R}\)</span>（20%）时间步长是恰当的；对低配位数情况，则时间步长选取为0.4<span class="math inline">\(T_{R}\)</span>（40%）会更合适。</p><h2 id="接触矢量">接触矢量</h2><p>当两个颗粒碰撞时，定义接触矢量为连接碰撞点和颗粒体中心的矢量。</p><h2 id="颗粒物料与颗粒流">颗粒物料与颗粒流</h2><p>颗粒物料是由众多离散颗粒相互作用而形成的具有内在有机联系的复杂系统。自然界中单个颗粒的典型尺度在10-6~10 m范围内，其运动规律服从牛顿定律。整个颗粒介质在外力或内部应力状况变化时发生流动，表现出流体的性质，从而构成颗粒流。</p><h2 id="力链">力链</h2><p>在重力作用下的密集流中，发生接触的颗粒间链接成直线状且较为稳定的力链，这些力链在整个颗粒介质内构成力链网络，支撑整个颗粒介质的重力及外载荷。颗粒物料内部接触应力的分布并不均匀，在密集排布的颗粒物质中，颗粒自由活动空间小，重力或外载荷使得颗粒间相互挤压变形，一些颗粒变形较大且连接成准直线形，传递较大份额的重力和外载荷，形成强力链；其他颗粒间接触变形微弱，传递的外力较小，形成弱力链。力链的方向基本与外载荷方向平行，只能承受较小的切向力。剪切过程中，这些力链发生动态变化：若干颗粒聚集而形成一条力链，随着剪切而发生轻微旋转，力链逐渐变得不稳定并最终断裂，但很快又形成新的力链与外载荷达到平衡。</p><h2 id="堆积角">堆积角</h2><p>所谓堆积角是指颗粒物料自由堆积在水平面上，且保持稳定的锥形料堆的最大锥角，即物料的自然坡度表面与水平面之间的夹角，称为最大堆积角。堆积角的值与颗粒物料的流动性有关，颗粒物料的流动性愈好，堆积角愈小。 形成颗粒物料的堆积角有两种情况：一种是底平面保持静止时的静堆积角，另--种是底平面保持运动时的动堆积角。</p><h2 id="无黏连球形颗粒接触力">无黏连球形颗粒接触力</h2><h3 id="法向力hertz理论">法向力（Hertz理论）</h3><p>不考虑颗粒表面黏连时，法向力一般采用Hertz接触理论计算。Hertz接触理论假设：相互接触的颗粒表面光滑且均质，与颗粒表面相比接触面很小，在接触面上仅发生弹性变形，且接触力垂直于该接触面。Hertz接触理论是颗粒曲面弹性接触问题的理论基础，适用于球体、柱体和椭球体等曲面体的弹性接触，甚至接触面之间微凸体的接触。</p><p>如下图所示，半径分别为R<sub>1</sub>和R<sub>2</sub>的两球形颗粒发生弹性接触，法向重叠量 <span class="math inline">\(\alpha\)</span> 为： <span class="math display">\[\alpha=R_{1}+R_{2}-\left|\boldsymbol{r}_{1}-\boldsymbol{r}_{2}\right|&gt;0  \]</span> 式中，颗粒1和颗粒2的半径分别为R<sub>1</sub>、R<sub>2</sub>；r<sub>1</sub>和r<sub>2</sub>是两颗粒的球心位置矢量。</p><h3 id="切向力mindlin-deresiewicz理论">切向力（Mindlin-Deresiewicz理论）</h3><h3 id="hertzmindlin-deresiewicz不足之处">Hertz、Mindlin-Deresiewicz不足之处</h3><blockquote><p>Hertz接触理论和MD接触理论都是针对颗粒弹性接触，事实上颗粒在接触过程中往往发生塑性变形。当加载时，法向力随重叠量近似线性变化，这说明具有恒定的有效弹性模量；卸载过程沿着不同的曲线，基本.上是线性的，只是更陡一-些，这说明卸载时有效弹性模量更大，这是由于塑性形变时颗粒间留下一变形平面，因此颗粒间较快失去接触，接触力降至零，见下图。另外，对颗粒表面施加多次连续的接触时，颗粒表面受撞击而变硬，也可能随着切向力的逐渐加载直至两颗粒表面发生相对滑移，颗粒表面的微小凹凸被摩擦掉，进而改变了颗粒表面性能，所以Hertz法向接触理论和MD切向接触理论属于理想情况。</p></blockquote><p><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/24/QXpc4izje9E5KCU.png" alt="image-20210115210804261"  /></p><h2 id="软球模型">软球模型</h2><p>球形颗粒接触理论严密，求解过程却相当烦琐，在不产生显著误差的条件下，有必要予以简化处理，软球模型和硬球模型就是目前常用的两类简化模型。<strong>软球模型</strong><code>把颗粒间法向力简化为弹簧和阻尼器，切向力简化为弹簧、阻尼器和滑动器，引人弹性系数和阻尼系数等参量。</code>软球模型不考虑颗粒表面变形，依据颗粒间法向重叠量和切向位移计算接触力，<code>不考虑接触力加载历史</code>，计算强度较小，适合于工程问题的数值计算。<strong>硬球模型</strong>则<code>完全忽略颗粒接触力大小和颗粒表面变形细节，接触过程简化为瞬间完成的碰撞过程，</code>碰后速度直接给出，是接触过程中力对时间积分的结果，碰撞过程中能量的耗散采用恢复系数予以表达，硬球模型主要应用于快速运动、低浓度颗粒体系的数值模拟。</p><iframe width="100%" height="800" class="embed-show" src="http://49.232.148.129/#fileView&amp;path=http%3A%2F%2F49.232.148.129%2F%3Fexplorer%2Fshare%2Ffile%26hash%3D870d70vspfXBzBHZBbu0g8Zx0vGiQ9U5PzU7Y-11CLTJz08EFrDbjfk%26name%3DEDEM%25E7%2590%2586%25E8%25AE%25BA%25E5%258F%2582%25E8%2580%2583%25E6%258C%2587%25E5%258D%2597.pdf%26size%3D653768%26createTime%3D1625564039" allowtransparency="true" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true" frameborder="0" scrolling="no"></iframe><h2 id="参考文献">参考文献</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="zotero://select/library/items/EFEX973C">颗粒系统的离散元素法分析仿真</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> DEM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDEM相似原理</title>
      <link href="/e9a76895.html"/>
      <url>/e9a76895.html</url>
      
        <content type="html"><![CDATA[<h2 id="仿真颗粒数量达到百万级数量">1.仿真颗粒数量达到百万级数量</h2><p>EDEM仿真改进方案：</p><p><code>离散元缩尺模型的建立与参数校核</code></p><p>在仿真过程中为了提高仿真效率对仿真模型的模型进行适当的缩小，通过利用<code>相似性理论</code>来建立缩尺模型。</p><p>缩尺模型是对比实际的物理模型将仿真模型按确定的比例进行缩小，缩小后的仿真模型和原有模型在结构上有相同的特征，同时满足其物理性质、目标分析参数不发生变化。</p><p>为了达到这一目标需要根据相似性理论建立新的模型并对参数进行修正。</p><blockquote><p>[1]肖纳. 基于EDEM的粉末冶金装粉过程研究[D].广州大学,2016.</p><p>[2]王文涛. 基于离散元法的铁粉模压成形数值仿真研究[D].中北大学,2014.</p></blockquote><p>相似原则</p><ol type="1"><li><p>几何相似</p></li><li><p>力学相似</p></li><li><p>动态相似</p></li></ol><blockquote><p>[1]Feng, Y.T., A. Munjiza，J. Loughran, "On upscaling of discrete element models: similarity principles". Engineering Computations, <strong>2009</strong>. 26(6): p. 599-609.</p><p>[2]Lu, G., J.R. Third，C.R. Müller, "Discrete element models for non-spherical particle systems: From theoretical developments to applications". Chemical Engineering Science, <strong>2015</strong>. 127: p. 425-465.</p><p>[3]Milkevych, V.et.al, "Modelling approach for soil displacement in tillage using discrete element method". Soil and Tillage Research, <strong>2018</strong>. 183: p. 60-71.</p><p>[4]Ucgul, M., J.M. Fielke，C. Saunders, "Three-dimensional discrete element modelling of tillage: Determination of a suitable contact model and parameters for a cohesionless soil". Biosystems Engineering, <strong>2014</strong>. 121: p. 105-117.</p></blockquote><p>缩尺模型（相似原理）两个基本问题：</p><blockquote><p>(1)升级后的DE/TEST模型在什么条件下才能准确地表示原始的物理问题？</p><p>(2)在一个实际的高阶离散元模型中，根据所用离散元的数量，该模型的求解精度是多少？ 或者从实际的角度来看，获得足够精确的解所需的最小粒子数量是多少？</p></blockquote><p>量纲分析技术和相似原理在实验测试中起着基础性的作用，并且已经在流体力学和岩土技术领域得到了很好的确立(Douglas，et al.，2005；Wood，2004)，它们基本上解决了上述第一个问题，但从某种意义上说，所有涉及的介质，固体和/或流体，都是连续的。 据作者所知，对于粒子/离散情况，还没有相应的技术得到显著发展。</p><p>此外，到目前为止，离散单元建模中的上述两个关键问题还没有得到很好的解决，<strong>目前还没有一个通用的数学框架来评估离散单元固有的建模误差</strong>。 这与有限元模型完全相反，在有限元模型中，已经发展了各种严格的数学理论来了解各种单元公式的性能，并通过连续的单元精化程度来估计解的收敛性。 先进的数值技术(如网格自适应)也可用来提供满足解精度要求的(几乎)优化的网格。 因此，迫切需要进行大量的基础研究，以便在更可靠的数学基础上建立目前的离散元方法。</p><p>离散单元系统由一组(非线性)常微分方程(牛顿运动方程)控制，具有“离散”性质；而有限元系统是由偏微分方程控制的“连续场”的离散化。 此外，同一离散单元系统可以表现为几种不同的状态：固体、流体、颗粒或它们的组合，并且能够动态变化；而连续介质系统的物理状态通常是定义良好且不变的。 精确解的概念也没有用数学术语很好地定义。 因此，开发一个数学框架来分析缩尺离散模型可能更具挑战性。</p><p>此外，DEM中使用的相互作用定律，定义为相互作用力与两个粒子之间的重叠或分离距离之间的关系，应以物理为基础，并可能取决于固有的单元长度尺度（例如赫兹接触定律）；而有限元法中描述应力-应变关系的本构模型通常与单元尺寸无关（即尺度无关）。此外，不同的离散单元形状和不同的初始填充配置（具有相同的离散单元尺寸分布）也可能导致显著不同的结果。</p><p>当前的工作试图对上面确定的DE /测试模型的第一个升级问题进行初步调查。 特别是，将根据三个相似性原则（即几何相似性，机械相似性和动态相似性）建立控制严格可扩展离散元素模型存在的条件。 此外，将引入尺度不变相互作用定律的概念，这对于获得完全相似的数值模型至关重要。 然后，研究了离散元素建模中许多最常用的交互定律的可伸缩性。 讨论将集中在离散元素建模上，但是将在适当的地方突出显示与实验室测试有关的问题。</p><h2 id="basics-formulations">2.Basics formulations</h2><h3 id="物理模型和比例模型">2.1物理模型和比例模型</h3><p>考虑由域中(随机)打包的3D粒子组成的通用粒子系统模型。 粒子受到外力(外力或重力)的作用，或域边界上规定的位移。 相应的缩放模型(离散元件或试验)也受到与物理模型中相同形式的载荷/边界条件的影响。 在下文中，下标p和m分别表示与物理模型和缩放模型相关联的任何量。 请注意，以下讨论基于常规3D设置，与2D情况的任何差异将在3.4节中概述</p><h3 id="粒子应变应力和相互作用定律">2.2粒子应变，应力和相互作用定律</h3><p>粒子系统建模中的一个关键问题是正确地建模粒子之间的相互作用力。 描述粒子之间作用力的相互作用定律通常可以表示为： <span class="math display">\[F=F(u, R, \xi)\]</span> 其中<span class="math inline">\(F\)</span>是法线或切线方向的接触力； <span class="math inline">\(R\)</span>代表本征粒子长度尺度； <span class="math inline">\(u\)</span>是两个接触/相邻粒子的重叠/分离/滑动距离，其初始值选择为<span class="math inline">\(F(0, R, 0)=0\)</span>。 <span class="math inline">\(\xi\)</span>表示一些内部参数/状态变量（如果存在）。 <span class="math inline">\(\xi\)</span>可能是基于“可塑性理论”的哥伦布摩擦模型中累积的“总”滑动距离（Han等，2000a，b）。为了简化讨论并突出关键问题，我们认为F是法向接触力，并且独立于<span class="math inline">\(\xi\)</span>,即<span class="math inline">\(F(0, R, 0)=0\)</span>，我们进一步假设粒子是球形的，尽管得出的结论通常也适用于其他形状的粒子。</p><p>颗粒的长度L，面积A和体积V。 对于半径为R的球面， <span class="math display">\[F(0, R, 0)=0L=2 R ; \quad A=L^{2} ; \quad V=A \times L=L^{3}\]</span> 并分别将标准粒子应变和应力确定为 <span class="math display">\[\varepsilon=u / L ; \quad \sigma(u, R)=F(u, R) / A\]</span> 然后 <span class="math display">\[\sigma=\sigma(\varepsilon, R)\]</span> 是颗粒应变-应力形式的相互作用定律，或者是经典连续体力学意义上的本构模型。我们进一步定义了粒子能量函数，<span class="math inline">\(E(u, R)\)</span>与相互作用力<span class="math inline">\(F(u, R)\)</span>相关 <span class="math display">\[E(u, R)=\int_{0}^{u} F(u, R) d u\]</span></p><p>同样，粒子应变能密度函数可以定义为 <span class="math display">\[e(R, \varepsilon)=\frac{E(u, R)}{V}=\int_{0}^{\varepsilon} \sigma(\varepsilon, R) d \varepsilon\]</span></p><p>和 <span class="math display">\[\sigma(\varepsilon, R)=\frac{d e(R, \varepsilon)}{d \varepsilon}\]</span></p><h2 id="可扩展性相似性原则">3.可扩展性–相似性原则</h2><p>接下来，将根据相似性原则建立一套完整的条件，在该条件下，缩放后的模型可以准确地表示原始物理模型的行为。</p><h4 id="几何相似">3.1几何相似</h4><p>第一个明显的条件是，比例模型在几何上必须是物理问题的精确表示，即需要严格遵守几何相似性的经典原则（Douglas等人，2005年）。更具体地说，两个模型，物理模型和比例模型，应该具有相同的填充配置，并且两个模型中的粒子大小和区域只在一个恒定的比例因子上不同</p><p>设比例因子为<span class="math inline">\(h\)</span>，<span class="math inline">\(Rp\)</span>和<span class="math inline">\(Rm\)</span>分别为物理模型和按比例放大模型中任意粒子的半径，<span class="math inline">\(Dp\)</span>和<span class="math inline">\(Dm\)</span>表示两个模型中域的特征长度。则几何相似性原理要求 <span class="math display">\[\frac{R_{m}}{R_{p}}=h ; \quad \frac{D_{m}}{D_{p}}=h\]</span> 并且两个模型中的颗粒填充结构应相同。</p><h4 id="力学相似">3.2力学相似</h4><p>现在考虑物理模型中半径为<span class="math inline">\(Rp\)</span>的任意粒子，其在一个主方向上的运动受牛顿第二定律控制： <span class="math display">\[M_{p} \ddot{u}_{p}+F_{p}\left(u_{p}, R_{p}\right)=Q_{p}(t)\]</span> <span class="math inline">\(Mp\)</span>是粒子的质量;<span class="math inline">\(F_{p}\left(u_{p}, R_{p}\right)\)</span>是来自相邻粒子的（结果）相互作用力； <span class="math inline">\(Q_{p}(t)\)</span>是施加在粒子上的任何（网格）外力；<span class="math inline">\(u_{p} \text { 和 } \ddot{u}_{p}\)</span>表示粒子在有关方向上的位移和加速度。</p><p>请注意，这是在两个方面大大简化的方程式：</p><p>（1）它表示沿粒子的六个主要自由度（即法向，切向和旋转）中的任意一个运动。</p><p>（2）接触力<span class="math inline">\(F_{p}\left(u_{p}, R_{p}\right)\)</span>是所有相邻粒子引起的，每个均由相应的相互作用定律确定。</p><p>为便于后续讨论，仅考虑沿指定方向的一个法向接触，和<span class="math inline">\(F_{p}\left(0, R_{p}\right)=0\)</span>。</p><p>或者，上述方程（9）可以用变分形式重写为 <span class="math display">\[M_{p} \ddot{u}_{p} \delta u_{p}+F_{p}\left(u_{p}, R_{p}\right) \delta u_{p}=Q_{p}(t) \delta u_{p}\]</span> <span class="math inline">\(\delta u_{p}\)</span>表示最小的容许位移 。</p><p>现在考虑一个准静态情况，其中等式（9）和（10）中的惯性项<span class="math inline">\(M_{p} \ddot{u}_{p}\)</span>微不足道，因此可以忽略，其中<span class="math inline">\(Q_{p}(t)=Q_{p}\)</span>（常数）。那么 <span class="math display">\[F_{p}\left(u_{p}, R_{p}\right)=Q_{p}\]</span> 或者 <span class="math display">\[F_{p}\left(u_{p}, R_{p}\right) \delta u_{p}=Q_{p} \delta u_{p}\]</span> 根据第2.2节中给出的定义，与颗粒相关的长度、面积和体积分别为： <span class="math display">\[L_{p}=2 R_{p} ; \quad A_{p}=L_{p}^{2} ; \quad V_{p}=L_{p}^{3}\]</span> 因此 <span class="math display">\[u_{p}=\varepsilon_{p} L_{p} ; \quad F_{p}\left(u_{p}, R_{p}\right)=\sigma_{p} A_{p}\]</span> 方程（11）和（12）现在可以分别用粒子应变、应力和应变能密度表示为 <span class="math display">\[\sigma_{p}\left(u_{p}, R_{p}\right)=q_{p}\]</span></p><p><span class="math display">\[\delta e_{p}\left(\varepsilon_{p}, R_{p}\right)=\delta w_{p}\left(\varepsilon_{p}\right)\]</span></p><p>其中 <span class="math display">\[q_{p}=Q_{p} / A_{p} ; \quad w_{p}\left(\varepsilon_{p}\right)=q_{p} \varepsilon_{p}\]</span> 同样，在比例模型中半径<span class="math inline">\(Rm\)</span>对应粒子的控制方程可以表示为 <span class="math display">\[\begin{array}{c}\sigma_{m}\left(u_{m}, R_{m}\right)=q_{m} \\\delta e_{m}\left(\varepsilon_{m}, R_{m}\right)=\delta w_{m}\left(\varepsilon_{m}\right)\end{array}\]</span> 式中，<span class="math inline">\(u_{m}, \varepsilon_{m}, \sigma_{m} \text { 和 } e_{m}\)</span>分别是缩放模型中的粒子应变、应力和能量密度。</p><p>现在我们声明，如果两个模型中的粒子应变，应力和应变能函数相同，则它们在力学上是相似的。 因此，力学相似原理要求 <span class="math display">\[\begin{array}{c}\varepsilon_{p}=\varepsilon_{m} \\\sigma_{p}\left(\varepsilon_{p}, R_{p}\right)=\sigma_{m}\left(\varepsilon_{m}, R_{m}\right) ; \quad \text { or } \quad e_{p}\left(\varepsilon_{p}, R_{p}\right)=e_{m}\left(\varepsilon_{m}, R_{m}\right) \\w_{p}=w_{m} ; \quad q_{p}=q_{m}\end{array}\]</span> 请注意，尽管似乎没有必要要求能量密度相等<span class="math inline">\(e_{p}=e_{m}\)</span>，但在处理更复杂的一般接触情况时将是有益的。</p><p>上述条件（19）在原始物理量中的对应形式为 <span class="math display">\[\frac{u_{p}}{L_{p}}=\frac{u_{m}}{L_{m}} ; \quad \frac{F_{p}\left(u_{p}, R_{p}\right)}{A_{p}}=\frac{F_{m}\left(u_{m}, R_{m}\right)}{A_{m}} ; \quad \frac{Q_{p}}{A_{p}}=\frac{Q_{m}}{A_{m}}\]</span> 结合几何相似条件，得出 <span class="math display">\[\frac{u_{m}}{u_{p}}=\frac{L_{m}}{L_{p}}=\frac{R_{m}}{R_{p}}=h ; \quad \frac{F_{m}\left(u_{m}, R_{m}\right)}{F_{p}\left(u_{p}, R_{p}\right)}=\frac{Q_{m}}{Q_{p}}=\frac{A_{m}}{A_{p}}=h^{2}\]</span> 按顺序应作如下说明：</p><p>（1） 等式（21）中的上述条件适用于所有机械接触情况，包括法向、切向和旋转（如果考虑），以及更复杂的接触，如存在粘性/粘性和液桥现象。</p><p>（2）关键相似条件<span class="math inline">\(\sigma_{p}\left(\varepsilon_{p}, R_{p}\right)=\sigma_{m}\left(\varepsilon_{m}, R_{m}\right)\)</span>是，如果相应的相互作用定律不是尺度不变的，则无法满足此条件。 有关相互作用定律可扩展性的重要问题将在第4节中进一步论。</p><p>当重力影响系统的行为时，还会出现另一个困难，因为现在在相同的地球重力场下， <span class="math display">\[\frac{Q_{m}}{Q_{p}}=\frac{M_{m} g}{M_{p} g}=\frac{V_{m}}{V_{p}}=h^{3}\]</span></p><p>式（21）要求<span class="math inline">\(Q_{m} / Q_{p}=h^{2}\)</span>。只有在试验中产生不同的（重力）加速度<span class="math inline">\(g_{m}\)</span>，才能解决这个问题。很容易得出正确的<span class="math inline">\(g_{m}\)</span>应该是 <span class="math display">\[g_{m}=g / h\]</span> 对于<span class="math inline">\(h&lt;1\)</span>的情况，即<span class="math inline">\(g_{m}&gt;g\)</span>，可以使用离心技术，并且它在岩土工程试验中已经越来越流行（Wood，2004）；而对于<span class="math inline">\(h&gt;1\)</span>的情况，可能必须使用特殊的实验室设施。</p><h4 id="动态相似性">3.3动态相似性</h4><p>当不能忽略粒子的惯性力时，必须满足附加条件，以确保可以在缩放模型中按比例缩小获得物理模型的结果。 下面将根据动态相似性原则建立所有必要条件。</p><p>遵循流体力学的传统处理方法（Douglas等，2005），动态相似性的定义是，作用在物理模型和比例模型中的所有力（惯性，内部和外部）都应具有相同的比率。因此，参考粒子的动力学方程式（9），动力学相似性原理要求： <span class="math display">\[\frac{M_{m} \ddot{u_{m}}}{M_{p} \ddot{u_{p}}}=\frac{F_{m}\left(u_{m}, R_{m}\right)}{F_{p}\left(u_{p}, R_{p}\right)}=\frac{Q_{m}(t)}{Q_{p}(t)}\]</span> 从准静态情况下得到的力学相似条件 <span class="math display">\[\frac{u_{p}}{u_{m}}=h ; \quad \frac{F_{m}\left(u_{m}, R_{m}\right)}{F_{p}\left(u_{p}, R_{p}\right)}=h^{2}\]</span> 我们有 <span class="math display">\[\frac{\ddot{u}_{m}}{\ddot{u}_{p}}=h ; \quad \frac{M_{m} \ddot{u}_{m}}{M_{p} \ddot{u}_{p}}=h^{2} ; \quad \frac{Q_{m}(t)}{Q_{p}(t)}=h^{2}\]</span> 这进一步导致 <span class="math display">\[\frac{M_{m}}{M_{p}}=h\]</span> 或者 <span class="math display">\[\frac{\rho_{m}}{\rho_{p}}=h^{-2}\]</span> 因此，在一般动态情况下，确保物理模型和缩放模型之间精确等效的所有条件都可以概括为 <span class="math display">\[\frac{R_{m}}{R_{p}}=h ; \quad \frac{\rho_{m}}{\rho_{p}}=h^{-2} ; \quad \frac{u_{m}}{u_{p}}=h ; \quad \frac{F_{m}\left(u_{m}, R_{m}\right)}{F_{p}\left(u_{p}, R_{p}\right)}=\frac{Q_{m}(t)}{Q_{p}(t)}=h^{2}\]</span> 尽管这些可以在离散元素模型中轻松实现，但上述相似性条件对实验室测试提出了严格的限制。 本质上，密度相似性条件<span class="math inline">\(\rho_{m} / \rho_{p}=h^{-2}\)</span>阻止了使用与物理问题相同的材料，因此很难同时增强接触力的相似性。 此外，如在准静态情况下一样，除非使用具有所需（等效）重力加速度的离心机或其他适当的测试设备，否则无法在测试模型中正确地研究重力效应。</p><h4 id="d案例的相似性原则">3.4 2D案例的相似性原则</h4><p>在前面的开发中，已经为一般的3D情况建立了三个相似性原则。由于二维离散元模型仍被广泛应用，因此需要给出相应的相似条件。这些条件可以通过遵循与三维情况相同的步骤来推导。然而，主要的区别在于颗粒应变和应力的定义。由于通常假定第三个方向上的单位厚度，半径为<span class="math inline">\(R\)</span>的二维粒子的应变和应力为 <span class="math display">\[\varepsilon=u / L ; \quad \sigma=F / A\]</span> 其中<span class="math inline">\(A=L=2 R\)</span>是特征区域，即等于特征长度。 通过使用这些修改的粒子应变和应力定义，可以建立三个相似条件</p><p>设 <span class="math inline">\(n_d =2,3\)</span>表示空间维度。二维和三维情况的完全相似条件见表一</p><h3 id="相互作用定律的可伸缩性">4 相互作用定律的可伸缩性</h3><p>在上述发展中，严格遵守准静态情况下的机械相似性和一般动态情况下的动力学相似性，具体取决于尺度不变相互作用定律的存在。这一节将讨论所谓的相互作用定律的可伸缩性，特别是评估离散元模型中常用的相互作用定律的标度不变性。</p><p>表一 二维和三维两种模型的相似条件</p><table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr class="header"><th>相似性</th><th>条件</th></tr></thead><tbody><tr class="odd"><td>几何</td><td>相同的模型包装配置; <span class="math inline">\(R_{m} / R_{p}=D_{m} / D_{p}=h\)</span></td></tr><tr class="even"><td>力学</td><td><span class="math inline">\(R_{m} / R_{p}=D_{m} / D_{p}=h\begin{array}{l}&lt;br/&gt;u_{m} / u_{p}=h ; F_{m}\left(u_{m}, R_{m}\right) / F_{p}\left(u_{p}, R_{p}\right)=Q_{m} / Q_{p}=h^{n_{d}-1}\end{array}\)</span></td></tr><tr class="odd"><td>动态</td><td><span class="math inline">\(u_{m} / u_{p}=h ; F_{m}\left(u_{m}, R_{m}\right) / F_{p}\left(u_{p}, R_{p}\right)=Q_{m} / Q_{p}=h^{n_{d}-1} ; \rho_{m} / \rho_{p}=1 / h^{n_{d}-1}\)</span></td></tr></tbody></table><p>作为接触力相似条件 <span class="math display">\[\frac{F_{m}\left(u_{m}, R_{m}\right)}{F_{p}\left(u_{p}, R_{p}\right)}=h^{2}\]</span> 是由于要求在相同的颗粒应变下，所有标度的颗粒应力必须相同： <span class="math display">\[\sigma_{p}\left(R_{p}, \varepsilon_{p}\right)=\sigma_{m}\left(R_{m}, \varepsilon_{m}\right) \quad \text { 其中 } \varepsilon_{p}=\varepsilon_{m}\]</span> 因此，颗粒应变-应力形式的相互作用定律必须仅取决于应变，且与颗粒固有长度无关： <span class="math display">\[\sigma(R, \varepsilon)=\sigma(\varepsilon)\]</span> 这种相互作用力被称为尺度不变性。因此，接触力相似性等价于相互作用定律的尺度不变性。</p><p>现在，我们研究离散元素建模中一些常用交互法则的可伸缩性。 请注意，对于2D和3D情况，粒子的特征长度，面积和体积可以统一描述为 <span class="math display">\[L=2 R ; \quad A=L^{n_{d}-1} ; \quad V=A L\]</span> 线性接触定律：<span class="math inline">\(F=k u\)</span></p><p>这是二维和三维问题中最常用的法向接触定律。然而，对应的颗粒应变-应力关系在二维和三维情况下有不同的形式，如下所示： <span class="math display">\[\sigma(R, \varepsilon)=\left\{\begin{array}{cl}k \varepsilon &amp; \text { for } 2 \mathrm{D} \\k \varepsilon / L &amp; \text { for } 3 \mathrm{D}\end{array}\right.\]</span> 由此可见，线性接触定律只对二维问题具有尺度不变性，而对三维问题则不具有尺度不变性。换句话说，当线性接触定律应用于三维时，“惩罚”系数 <span class="math inline">\(k\)</span> 必须与比例因子成反比。</p><p><em>两个湿球之间的液桥力（3D）</em></p><p>假设两个球体之间的内聚力（假设两个球体之间的内聚力）是相同的（1994年）。 <span class="math display">\[F=\underbrace{2 \pi \gamma R \sin \phi \sin (\phi+\theta)}_{\text {表面张力 }}+\underbrace{\pi R^{2} \Delta p(R, u, \phi, \theta) \sin ^{2} \phi}_{\text {静水压力}}\]</span></p><h3 id="结束语">5结束语</h3><p>本文建立了几何相似性、力学相似性和动态相似性三个相似性原则，这是比例模型准确再现物理模型力学行为的必要条件。这些原理也适用于两种不同比例离散元模型的等价性。特别是，机械相似性要求使用尺度不变的相互作用定律。很明显，一些最常用的相互作用定律不能满足这一要求，因而在离散元建模中产生了值得进一步关注的理论和实际意义.</p><p>另一方面，在离散单元模型中应用尺度不变的相互作用定律时，可以很容易地保持力学和动力学的相似性。然而，在离散单元建模中，几何相似性成为问题。基本上，如果要满足几何相似性，就必须使用与物理模型中相同数量的粒子，这就不可避免地导致在当前可用的计算机能力下，几乎难以实现任何实际应用的数值模型。事实上，在所有的物理条件下，没有相似性的建模都是等价的。</p><p>因此，为了将离散元模型的问题规模缩小到一个合理的水平，必须采用比域更大的离散元。或者，在涉及广泛的粒度分布的问题中，通常主导三维问题模型大小的较小尺寸的粒子要么被排除，要么被人为放大。在这两种情况下，几何相似性被破坏，离散单元模型中会引入建模误差。如果比例模型中的颗粒堆积结构不是物理模型的精确复制，即使在统计意义上颗粒尺寸分布相同，也可能违反严格的几何相似条件。 由于破坏几何相似性而导致的建模误差，以及使用非标度不变性的相互作用定律，因此成为下一个需要解决的重要计算问题。相关工作稍后汇报。</p>]]></content>
      
      
      <categories>
          
          <category> DEM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相似原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown常用语法</title>
      <link href="/a1c1.html"/>
      <url>/a1c1.html</url>
      
        <content type="html"><![CDATA[<h1 align="center">数学公式</h1><p>Butterfly内部提供数学公式渲染的引擎，这样你就不需要自己手动在模板中引入 JS 或者 CSS； 只需要选择对应的渲染引擎，并在 <code>_config_butterfly.yml</code> 中将其 <code>enable</code> 选项改为 <code>true</code> 即可。</p><p>需要注意的是，仅仅将 <code>enable</code> 打开<strong>并不能让你看到数学公式</strong>，你还需要<strong>使用对应的 Hexo 渲染器(Renderer)</strong> 才能真正在博客页面中显示出数学公式。引擎对应使用的 Hexo 渲染器会在引擎相关的部分介绍。</p><h2 align="center">提供的渲染引擎</h2><p>目前，有两种数学公式渲染引擎，分别为 <a href="https://www.mathjax.org/">MathJax</a> 和 <a href="https://khan.github.io/KaTeX/">Katex</a>。</p><h3 id="mathjax">MathJax</h3><p>如果你选择使用 MathJax 进行数学公式渲染，你需要使用 <a href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a> 或者 <a href="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a> （不推荐）作为 Hexo 的 Markdown 渲染器。</p><p>首先，卸载原有的渲染器 <code>hexo-renderer-marked</code>，并安装这两种渲染器的<strong>其中一个</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-pandoc <span class="comment"># 或者 hexo-renderer-kramed</span></span><br></pre></td></tr></table></figure><p>然后在 <code>next/_config.yml</code> 中将 <code>mathjax</code> 的 <code>enable</code> 打开。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>执行 Hexo 生成，部署，或者启动服务器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br><span class="line"><span class="comment"># 或者 hexo clean &amp;&amp; hexo s</span></span><br></pre></td></tr></table></figure><h4 id="使用-mathjax-给公式编号并引用公式">使用 MathJax 给公式编号并引用公式</h4><p>在新版本的 NexT 主题中，我们加入了公式自动编号和引用功能。下面简要介绍一下如何使用这项功能。</p><p>为了使用这项功能，一般来说，你必须把所使用的 LaTeX 公式放在 <code>equation</code> 环境里面，采用旧的方法（也就是说，仅仅把公式的每一边用两个 $ 符号包含起来）是无效的。如何引用公式？你只需要在书写公式的时候给公式一个 <code>\label&#123;&#125;</code> 标记（tag），然后在正文中，可以使用 <code>\ref&#123;&#125;</code> 或者 <code>\eqref&#123;&#125;</code> 命令来引用对应的公式。使用 <code>\eqref&#123;&#125;</code> 是推荐的方式，因为如果你使用 <code>\ref&#123;&#125;</code>，公式在文中的引用编号将没有圆括号包围。下面介绍几种常见的公式编号例子。</p><p>对于简单的公式，使用下面的方式给公式一个标记，</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\begin</span>&#123;equation&#125;<span class="keyword">\label</span>&#123;eq1&#125;</span><br><span class="line">e=mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>然后，在正文中，你可以轻松引用上述公式，一个简单的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">著名的质能方程 $\eqref&#123;eq1&#125;$ 由爱因斯坦提出 ...</span><br></pre></td></tr></table></figure><p>对于多行公式，在 <code>equation</code> 环境中，你可以使用 <code>aligned</code> 环境把公式分成多行，</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\begin</span>&#123;equation&#125;<span class="keyword">\label</span>&#123;eq2&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">a <span class="built_in">&amp;</span>= b + c <span class="keyword">\\</span></span><br><span class="line">  <span class="built_in">&amp;</span>= d + e + f + g <span class="keyword">\\</span></span><br><span class="line">  <span class="built_in">&amp;</span>= h + i</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>要对齐多个公式，我们需要使用 <code>align</code> 环境。align 环境中的每个公式都有自己的编号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;align&#125;</span><br><span class="line">a &amp;&#x3D; b + c \label&#123;eq3&#125; \\</span><br><span class="line">x &amp;&#x3D; yz \label&#123;eq4&#125;\\</span><br><span class="line">l &amp;&#x3D; m - n \label&#123;eq5&#125;</span><br><span class="line">\end&#123;align&#125;$$</span><br></pre></td></tr></table></figure><p>在 <code>align</code> 环境中，如果你不想给某个或某几个公式编号，那么在这些公式后面使用 <a href="https://tex.stackexchange.com/questions/17528/show-equation-number-only-once-in-align-environment"><code>\nonumber</code></a> 命令即可。例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">-4 + 5x <span class="built_in">&amp;</span>= 2+y <span class="keyword">\nonumber</span>  <span class="keyword">\\</span></span><br><span class="line"> w+2 <span class="built_in">&amp;</span>= -1+w <span class="keyword">\\</span></span><br><span class="line"> ab <span class="built_in">&amp;</span>= cb</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>有时，你可能会希望采用更加奇特的方式来标记和引用你的公式，你可以通过使用 <code>\tag&#123;&#125;</code> 命令来实现，例如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span>x+1<span class="keyword">\over</span><span class="keyword">\sqrt</span>&#123;1-x<span class="built_in">^</span>2&#125; <span class="keyword">\tag</span>&#123;i&#125;<span class="keyword">\label</span>&#123;eq<span class="built_in">_</span>tag&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>如果你想要了解更多信息，请访问 <a href="https://docs.mathjax.org/en/latest/input/tex/eqnumbers.html">MathJax 关于公式编号的官方文档</a>。同时，你也可以阅读 <a href="https://theme-next.org/docs/third-party-services/math-equations">这篇文档</a> 来获取更多细节信息。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora常用快捷键命</title>
      <link href="/a47819e6.html"/>
      <url>/a47819e6.html</url>
      
        <content type="html"><![CDATA[<h1 id="typora常用快捷键命令">Typora常用快捷键命令</h1><h2 id="段落">段落</h2><ul><li>标题：Ctrl+1/2/3/4/5</li><li>段落：Ctrl+0</li><li>增大标题级别：Ctrl+=</li><li>减少标题级别：Ctrl+-</li><li>表格：Ctrl+T</li><li>代码块：Ctrl+Shift+K</li><li>公式块：Ctrl+Shift+M</li><li>引用：Ctrl+Shift+Q</li><li>有序列表：Ctrl+Shift+[</li><li>无序列表：Ctrl+Shift+]</li><li>增加缩进：Ctrl+]</li><li>减少缩进：Ctrl+[</li><li>目录： [toc]</li><li>文章内跳转： <code>[跳转提示文字](#跳转的标题)</code></li></ul><h2 id="格式">格式</h2><ul><li><p>加粗：Ctrl+B</p></li><li><p>斜体：Ctrl+I</p></li><li><p>下划线：Ctrl+U</p></li><li><p>代码：Ctrl+Shift+`</p></li><li><p>删除线：Alt+Shift+5</p></li><li><p>超链接：Ctrl+K</p></li><li><p>图像：Ctrl+Shift+I</p></li><li><p>清除样式：Ctrl+</p></li></ul><figure><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/24/5zcUvu7GxSargY9.png" alt="https://img2018.cnblogs.com/blog/443934/201810/443934-20181012170159282-378811511.png" /><figcaption aria-hidden="true">https://img2018.cnblogs.com/blog/443934/201810/443934-20181012170159282-378811511.png</figcaption></figure><p><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/24/QxegsOlXd9kGcSD.png" /></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散元素法的基本原理与力学模型</title>
      <link href="/20fc.html"/>
      <url>/20fc.html</url>
      
        <content type="html"><![CDATA[<p>离散元方法是由分析离散单元的块间接触入手找出其接触的本构关系建立接触的物理力学模型并根据牛顿第二定律对非连续、离散的单元进行模拟仿真。而有限元方法是将介质复杂几何区域离散为具有简单几何形状的单元通过单元集成、外载和约束条件的处理得到方程组再求解该方程组就可以得到该介质行为的近似表达。</p><h1 id="基本思想">基本思想</h1><p>离散元素法的基本原理是，将研究对象划分为一个个相互独立的单元，根据单元之间的相互作用和牛顿运动定律，采用<strong>动态松弛法</strong>或<strong>静态松弛法</strong>等迭代方法进行循环迭代计算，确定在每一个时间步长所有单元的受力及位移，并更新所有单元的位置。通过对每个单元的微观运动进行跟踪计算，即可得到整个研究对象的宏观运动规律。在离散元素法中，单元间的相互作用被看做是瞬态平衡问题，并且只要对象内部的作用力达到平衡，就认为其处于平衡状态。离散元素法的基本假设是：选取的时间步长足够小，使得在一个单独的时间步长内，除了与选定单元直接接触的单元外，来自其他任何单元的扰动都不能传播过来；并且规定在任意的时间步长内，速度和加速度恒定。以上的假设非常重要，它是离散元素法的前提条件。而且由此得到以下结论：在任意时刻单元所受到的作用力只取决于该单元本身及与之直接接触的其他单元。</p><p>离散元素法的基本原理主要有两个方面的意义：一个是接触模型，即力位移关系；另一个是牛顿第二定律。<strong>接触模型用于单元接触力的计算，牛顿第二定律则用于求解单元的位移、速度及加速度。</strong>由于离散元素法是建立在牛顿第二定律和不同的接触模型的基础之上，而且该方法研究处理的对象及问题多种多样，因此它所采用的分析模型和计算方法也是不同的。<strong>对于散体颗粒体系，将单个颗粒（圆盘或球体）作为一个单元；对于岩石体系，将单个多边形块体一个单元。</strong></p><ol type="1"><li>离散单元法视世界由若干微粒（颗粒，particle）组成；</li><li>离散单元法将时间细分为若干时间间隔（时间步，time step）；</li><li>在每个时间间隔：颗粒接触传递相互作用力一牛顿力学求解颗粒加速度一线性积分得到颗粒速度和位移一更新系统状态；</li><li>重复3，自然模拟随着时间流逝的系统变化。</li></ol><h2 id="不同之处">不同之处</h2><ol type="1"><li><p>微粒（颗粒）是个质点，没有形状；</p></li><li><p>在每个时间间隔，颗粒动力学数据由分子势函数求解，而非牛顿力学；</p></li><li><p>颗粒之间的相互作用不需物理接触。</p></li></ol><h3 id="离散元优势">离散元优势</h3><p>相比有限单元法（Finite Element Method），离散单元法优势： 1，显式迭代，无收敛问题； 2，颗粒（单元）可以自由移动和接触/不接触，系统状态由时间自然演化控制，不需额外假定即可模拟大变形和破裂问题。</p><h3 id="劣势-计算效率">劣势-计算效率</h3><p>1，离散单元法获得不失真解的临界时间步长一般在10-5s以下，现有计算能力无法做到一秒内仿真100000步以上，故无法实现实时仿真。 2，通过超级计算机实现大规模问题并行计算，是目前主流的离散元仿真提速的方法。</p><h2 id="网格划分">网格划分</h2><p>网格划分粗细是一个值得考究的内容。 太粗则邻近搜索效果有限（接近不划网格）；太细则邻近搜索等同于接触判定，降低效率。动态网格值得考虑。</p><h3 id="接触判断">接触判断</h3><p>接触判断（contact detection）是运用数学方法，逻辑判断两个接近的颗粒是否有接触。如有接触，还需要得出接触点的几何数据（接触点位置、法向方向等），以便于下一步计算。 此处用球形颗粒为例简单介绍接触判断过程。非球形颗粒的接触判断较为复杂，将在第四讲探讨。</p><h3 id="接触分析">接触分析</h3><p>接触分析（contact evaluation）是运用接触模型，利用接触点相对位移（转角）等，计算得到接触传力（力矩），并分别作用于两个接触颗粒的过程。 接触模型（contact model），又叫接触本构模型，是一系列力- 位移表达式，其通式如下，具体将在第二、三讲讨论。</p><h2 id="总结">总结</h2><blockquote><ol type="1"><li>离散单元法是由Cundall和Strack于1979年提出的一种数值仿真方法；</li><li>系统由颗粒组成，自然模拟时间流逝和系统状态演化，显式迭代无收敛问题，亦不强制要求介质连续；离散单元法可用于各类工程问题的仿真； 4·离散单元法仿真，每一时间步内将要进行四个步骤的运算：<strong>邻近搜索、接触判断、接触分析、数值积分。</strong>离散元素法的基本原理主要有两个方面的意义：一个是接触模型，即力位移关系；另一个是牛顿第二定律。接触模型用于单元接触力的计算，牛顿第二定律则用于求解单元的位移、速度及加速度。由于离散元素法是建立在牛顿第二定律和不同的接触模型的基础之上，而且该方法研究处理的对象及问题多种多样，因此它所采用的分析模型和计算方法也是不同的。对于散体颗粒体系，将单个颗粒（圆盘或球体）作为一个单元；对于岩石体系，将单个多边形块体一个单元。</li></ol></blockquote><h1 id="离散元颗粒模型">离散元颗粒模型</h1><p>离散元素法把分析对象看成充分多的离散单元，每个颗粒或块体为一个单元，根据全过程中的每一时刻各颗粒间的<strong>相互作用计算接触力</strong>，再运用牛顿运动定律计算单元的运动参数，这样交替反复运算，实现对象运动情况的预测。根据几何特征不同，可将离散体单元分为颗粒和块体两大类，相应地离散元素法也分为颗粒离散元素法和块体离散元素法，前者面向各种颗粒形状的散体或粉体，而后者则主要是针对岩石或岩土问题而提出的，其区别在于形体特征引起的接触模型和相关的计算、搜索和信息存储等方面的差别。</p><p>根据处理问题的不同，颗粒模型和计算方法又有不同，一般有<strong>硬球模型</strong>和<strong>软球模型</strong>两种类型。这两种方法在计算效率和应用上不尽相同，各有优点。硬球模型主要用来模拟如库特流、剪切流中颗粒运动比较快的情况，颗粒之间的碰撞是瞬时的，在碰撞过程中颗粒本身不会产生显著的塑性变形，这样只考虑两个颗粒的同时碰撞，而不用同时计算三个以上颗粒之间的碰撞。软球模型主要用来模拟两个颗粒间的碰撞过程，也可以同时有两个以上的颗粒碰撞，它们之间的碰撞发生在一段时间范围之内，利用牛顿第二定律，根据球体间的交叠量可以计算得到颗粒间的接触力。</p><p>颗粒模型中颗粒的运动是相互独立的，只有当发生接触时才会在接触点处产生相互作用。颗粒的离散性使得它在受载和不受载的情形下会产生复杂的运动，因此到目前为止，还不能建立一个令人满意的接触模型。最常用的颗粒模型是把颗粒看做圆盘或球体，即二维刚性圆形颗粒模型和三维刚性球形颗粒模型，图1-2为颗粒相互接触及颗粒与边界接触的情况。图1-2所示的接触状态可以抽象为图1-3的涵盖颗粒与颗粒、颗粒与边界的Hertz接触模型，其中R1、R2分别为颗粒Z1、Z2的接触半径，A为接触圆半径，8为接触变形量。</p><p>离散元素法的颗粒模型是将颗粒与颗粒、颗粒与边界的接触采用振动运动方程进行模拟。图1-4为将接触模型表示成振动模型，振动运动的法向运动和切向运动如图1-5（a）和1-5（b）的法向和切向振动模型所示，颗粒与颗粒、颗粒与边界之间的滑动如图1-5（c）的滑动模型所示.</p><p><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2020/08/03/vLb1NIrVS4k8zd3.png"  /> <span class="math display">\[F=\frac{2}{3}\left[4\left(\frac{\varepsilon}{h_{0}}\right)^{2}-\left(\frac{\varepsilon}{h_{0}}\right)^{8}\right] \pi R^{*} \Delta \gamma\]</span></p>]]></content>
      
      
      <categories>
          
          <category> DEM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代设计方法原理</title>
      <link href="/c2b5ee8a.html"/>
      <url>/c2b5ee8a.html</url>
      
        <content type="html"><![CDATA[<h1 id="现代设计方法">现代设计方法</h1><h2 id="响应面分析">响应面分析</h2><p>在过程优化里，最常用到的方法有三个：单因素试验、正交试验和响应面分析。其中，单因素试验是在假设因素间不存在交互作用的前提下，每次只改变一个因素且保证其他因素维持在恒定水平的条件下，研究不同试验水平对响应值的影响。 然而，大多数过程影响因素相当复杂，而且因素间通常又存在交互作用，并且当试验因素很多时，需要进行多次试验和较长的试验周期才能完成各因素的逐个优化。 正交试验可同时考虑多个因素，注重科学合理安排试验，以寻找最佳的因素水平组合。它的试验次数明显少于同因素同水平的单因素试验，可通过方差分析得到影响试验结果的主次因素，以及考虑因素间的交互作用等等。 但当考虑因素之间的交互作用时，其试验次数会大大增加，工作量巨大。 这个时候，响应面分析应运而生 响应面分析法，即响应曲面设计方法（Response Surface Methodology，RSM），是通过设计合理的有限次数试验，建立一个包括各显著因素的一次项、平方项和任何两个因素之间的一级交互作用项的数学模型，精确研究各因素与响应值之间的关系，快速有效地确定多因素系统的最佳条件。 该方法具有试验次数少、周期短、精度高等优点，是一种有效地优化基础试验条件的技术。 什么时候可以选用响应面法进行分析？ 当你确信或者怀疑因素对指标存在非线性影响，所有因素均为计量值数据并且试验区域已接近最优区域的时候，就可以用响应面法来设计优化你的试验。响应面分析的一般步骤： 确定因素及水平：注意因素数一般不超过 4 个，因素均为计量值数据 方法选择：创建<code>「中心复合」或者「Box-Behnken」设计</code></p><ul><li>确定试验运行顺序</li><li>进行试验并收集数据</li><li>分析试验数据</li><li>优化因素的设置水平</li><li>验证试验 其中，确定因素方法一般采用 Plackett-Burman 法，这是一种以不完全平衡块（balanced incomplete blocks）为原理的部分析因实验设计法，适用于从众多的考察因素中快速、有效的筛选出最为重要的几个因素，供进一步详细研究使用。 确定水平一般采用最陡爬坡试验，该试验分别对 3 个显著因素的正负效应设计最陡爬坡试验路径，包括各因素的变化步长和变化方向，以便最快地逼近最大响应区域。 响应面常用的方法有两种：中心复合试验设计（central composite design，CCD）和 Box-Behnken 试验设计（BBD）。 常用的响应面设计和分析软件有 Matlab、SAS 和 Design-Expert。在已经发表的有关响应面（RSM）优化试验的论文中，Design-Expert 是使用最广泛的软件。 Design-Expert 软件是由 State-East 公司开发的一款面向试验设计的相关分析的软件，相对于其他数理分析软件 JMP、SAS、Minitab 等，它具有使用简单，不需数理统计功底，就可以用设计出高效的试验方案，并对实验数据做专业的分析，给出全面、可视的模型以及优化结果。</li></ul><h2 id="多维无约束优化方法">多维无约束优化方法</h2><p>多维无约束优化问题的一般数学表达式为 <span class="math display">\[\min f(X)=f\left(x_{1}, x_{2}, \cdots, x_{n}\right), \quad X \in R^{n}\]</span> 求解这类问题的方法，称为多维无约束优化方法。它也是构成约束优化方法的基础算法。 多维无约束优化方法是优化技术中最重要和最基本的内容之一。因为它不仅可以直接用来求解无约束优化问题，而且实际工程设计问题中的大量约束优化问题，有时也是通过对约束条件的适当处理，转化为无约束优化问题来求解的。所以，无约束优化方法在工程优化设计中有着十分重要的作用。 多维无约束优化方法，根据其确定搜索方向所使用的信息和方法的不同，可分为两大类：一是需要利用目标函数的一阶偏导数或二阶偏导数来构造搜索方向，如梯度法、共轭梯度法、牛顿法和变尺度法等。这类方法由于需要计算偏导数，因此计算量大，但收敛速度较快，一般称之为间接法。另一类是通过几个已知点上目标函数值的比较来构造搜索方向，如坐标轮换法、随机搜索法和共轭方向法等。这类方法由于只需要计算函数值，因而对于无法求导或求导困难的函数，该法就有了突出的优越性，但是其收敛速度较慢，一般称之为直接法。 各种优化方法之间的主要差异是在于构造的搜索方向，因此，关于搜索方向S<sup>（k）</sup>的选择问题，是最优化方法要讨论的重要内容。下面介绍几种经典的无约束优化方法。</p><h3 id="变尺度法">变尺度法</h3><p>变尺度法的提出与梯度法和牛顿法有着密切联系。它是一种拟牛顿法。所谓拟牛顿法是指基于牛顿法的基本原理而又对牛顿法作了重要改进的一种方法。这种方法克服了梯度法收敛慢和牛顿法计算量大的缺点，而又继承了牛顿法收敛速度快和梯度法计算简单的优点。理论和实践表明，变尺度法是求解无约束优化问题最有效的算法之一，是目前应用比较广泛的一种算法。变尺度法的种类很多，本节介绍其中最重要的两种：<strong>DFP变尺度法</strong>和<strong>BFGS变尺度法</strong>。</p><h4 id="dfp变尺度法"><strong>DFP变尺度法</strong></h4><p>变尺度法的基本思想是：利用牛顿法的迭代形式，但并不直接计算<span class="math inline">\(\left[H\left(X^{(k)}\right)\right]^{-1}\)</span>，而是用一个对称正定矩阵A<sup>(k)</sup>近似地代替<span class="math inline">\(\left[H\left(X^{(k)}\right)\right]^{-1}\)</span>在迭代过程中，不断地改进，最后逼近<span class="math inline">\(\left[H\left(X^{(k)}\right)\right]^{-1}\)</span>。这种方法，省去了海森矩阵的计算和求逆，使之计算量大为减少，而且还保持了牛顿法收敛快的优点。由于这一方法的迭代形式与牛顿法类似，所以又称拟牛顿法。</p><p>DFP变尺度法是由戴维顿（Davidon）首先提出，后经费莱彻（Fletcher）和鲍威尔（Powell）对之做了改进，因而称为DFP变尺度法。DFP变尺度法的迭代公式为 <span class="math display">\[X^{(k+1)}=X^{(k)}+\alpha^{(k)} S^{(k)}=X^{(k)}-\alpha^{(k)} A^{(k)} \nabla f\left(X^{(k)}\right) \label{eq:2-47}\]</span> 式中，<span class="math inline">\(\alpha\)</span><sup>(k)</sup>为变尺度法的最优步长；<span class="math inline">\(- A^{(k)} \nabla f\left(X^{(k)}\right)\)</span>为搜索方向，即<span class="math inline">\(S^{(k)}=-A^{(k)} \nabla f\left(X^{(k)}\right)\)</span>，称之为拟牛顿方向；A<sup>(k)</sup>为变尺度矩阵，是<span class="math inline">\(-n \times n\)</span>阶对称正定矩阵，在迭代过程中它是逐次形成并不断修正，即从一次迭代到另一次迭代是变化的，故称变尺度矩阵。 不难看出，当A<sup>(k)</sup>=Ⅰ（单位矩阵）时，式<span class="math inline">\(\eqref{eq:2-47}\)</span>变为 <span class="math display">\[X^{(k+1)}=X^{(k)}-\alpha^{(k)} \nabla f\left(X^{(k)}\right)\]</span></p><p>当<span class="math inline">\(X^{(k+1)}=X^{(k)}-\alpha^{(k)}\left[H\left(X^{(k)}\right)\right]^{-1} \nabla f\left(X^{(k)}\right)\)</span>时，式<span class="math inline">\(\eqref{eq:2-47}\)</span></p><p><span class="math display">\[X^{(k+1)}=X^{(k)}-\alpha^{(k)}\left[H\left(X^{(k)}\right)\right]^{-1} \nabla f\left(X^{(k)}\right)\]</span></p><figure><img src= "img/ballloading.gif" data-lazy-src="https://i.loli.net/2021/01/21/c58tKN1GIEQTObe.png" alt="image-20210121192108447" /><figcaption aria-hidden="true">image-20210121192108447</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 现代设计方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>劝君自勉</title>
      <link href="/802bea05.html"/>
      <url>/802bea05.html</url>
      
        <content type="html"><![CDATA[<h1 id="心理陷阱">心理陷阱</h1><h2 id="稀缺陷阱">稀缺陷阱</h2><p>为了短暂的利益放弃了长远的规划。一般都是紧急的事情和工作，明天要交的作业，月末还没完成的指标，年末要交的策划。这些任务的紧急性导致你被迫花费大量时间去做，然后产生自我努力的感觉。但这只是你努力完成该完成任务的假像，这是应该的。对自己没有提升</p><h2 id="认知陷阱">认知陷阱</h2><p>输入≠努力，输出更重要（参考以前讲过的，将刚学的知识给别人复述或教一遍是最高效的记忆）。不是把只是记在笔记上就会了，不是背过数学公式就会做题了，不是办了健身房会员卡就有好身材了。要去实践，你打游戏也不是光读完技能介绍就玩的666呀。</p><h2 id="沉浸陷阱">沉浸陷阱</h2><p>大数据时代根据你浏览和搜索记录给你推送相似内容，使你的网络信息环境都保持在一个舒适圈，像一个茧蛹一样。慢慢让你陷入，沉迷，自己都没发现。注意手机的正确使用。</p><h2 id="美化陷阱">美化陷阱</h2><p>人类擅长自我美化，或者说找客观原因当做自己不完美的借口。人要更真实，努力也一样，真实的努力更有效果。敢于面对自己，接受自己，才能更好的认识自己，才能根据自身情况做有意义的努力。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激励 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
